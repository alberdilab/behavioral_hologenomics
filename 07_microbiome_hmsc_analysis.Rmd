# Dominance-microbiome analysis

```{r load_data_hmsc_analysis}
load("data/data.Rdata")
load("hmsc/fit_model1_250_10.Rdata")
```

### Posterior estimates
The next step is to get the posterior estimates of beta, which is the parameter that links dominance with the microbiome. We employ a support threshold of '0.05' to assign significance, meaning that parameters with posterior overlaps of <10% are considered significantly different.

```{r hmsc_postestimates, warning=FALSE, comments="", message=FALSE, fig.height=8, fig.width=10, fig.fullwidth=TRUE}
# Select desired support threshold
support=0.9
negsupport=1-support

# Basal tree
postestimates_tree <- genome_tree %>%
        keep.tip(., tip=m$spNames) 

# Posterior estimate table
post_beta <- getPostEstimate(hM=m, parName="Beta")$support %>%
    as.data.frame() %>%
    mutate(variable=m$covNames) %>%
    pivot_longer(!variable, names_to = "genome", values_to = "value") %>%
    mutate(genome=factor(genome, levels=rev(postestimates_tree$tip.label))) %>%
    mutate(value = case_when(
          value >= support ~ "Positive",
          value <= negsupport ~ "Negative",
          TRUE ~ "Neutral")) %>%
    mutate(value=factor(value, levels=c("Positive","Neutral","Negative"))) %>%
    pivot_wider(names_from = variable, values_from = value) %>%
    rename(intercept=2) %>%
    select(genome,dominance,groupvariable) %>%
    column_to_rownames(var="genome")

# Aggregate basal GIFT into elements
function_table <- genome_gifts %>%
    to.elements(., GIFT_db) %>%
    as.data.frame()

#Phylums
phylum_colors <- read_tsv("https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv") %>%
    right_join(genome_metadata, by=join_by(phylum == phylum)) %>%
    filter(genome %in% postestimates_tree$tip.label) %>%
    arrange(match(genome, postestimates_tree$tip.label)) %>%
    mutate(phylum = factor(phylum, levels = unique(phylum))) %>%
    column_to_rownames(var = "genome") %>%
    select(phylum)


colors_alphabetic <- read_tsv("https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv") %>%
  right_join(genome_metadata, by=join_by(phylum == phylum)) %>%
    filter(genome %in% postestimates_tree$tip.label) %>%
    arrange(match(genome, postestimates_tree$tip.label)) %>%
     select(phylum, colors) %>%
    unique() %>%
    arrange(phylum) %>%
    select(colors) %>%
    pull()

# Basal ggtree
postestimates_tree <- postestimates_tree %>%
        force.ultrametric(.,method="extend") %>%
        ggtree(., size = 0.3)

#Add phylum colors next to the tree tips
postestimates_tree <- gheatmap(postestimates_tree, phylum_colors, offset=-0.2, width=0.1, colnames=FALSE) +
      scale_fill_manual(values=colors_alphabetic)+
      labs(fill="Phylum")

#Reset fill scale to use a different colour profile in the heatmap
postestimates_tree <- postestimates_tree + new_scale_fill()

# Add posterior significant heatmap
postestimates_tree <- gheatmap(postestimates_tree, post_beta, offset=0, width=0.2, colnames=TRUE, colnames_position="top",colnames_angle=90, colnames_offset_y=1, hjust=0) +
        scale_fill_manual(values=c("#be3e2b","#f4f4f4","#b2b530"))+
        labs(fill="Trend")

#Reset fill scale to use a different colour profile in the heatmap
postestimates_tree <- postestimates_tree + new_scale_fill()

#Add functions heatmap
postestimates_tree <- gheatmap(postestimates_tree, function_table, offset=0.6, width=3.5, colnames=FALSE) +
            vexpand(.08) +
            coord_cartesian(clip = "off") +
            scale_fill_gradient(low = "#f4f4f4", high = "steelblue", na.value="white") +
            labs(fill="Function fullness")

#Reset fill scale to use a different colour profile in the heatmap
postestimates_tree <- postestimates_tree + new_scale_fill()

# Add completeness barplots
postestimates_tree <- postestimates_tree +
            geom_fruit(data=genome_metadata,
            geom=geom_bar,
            grid.params=list(axis="x", text.size=2, nbreak = 1),
            axis.params=list(vline=TRUE),
            mapping = aes(x=length, y=genome, fill=completeness),
                 offset = 3.85,
                 orientation="y",
                 stat="identity") +
            scale_fill_gradient(low = "#cf8888", high = "#a2cc87") +
            labs(fill="Genome completeness")

postestimates_tree +
        vexpand(.25, 1) # expand top 
```

### Positively associated genomes

```{r positive_table, warning=FALSE, comments="", message=FALSE}
getPostEstimate(hM=m, parName="Beta")$support %>%
    as.data.frame() %>%
    mutate(variable=m$covNames) %>%
    pivot_longer(!variable, names_to = "genome", values_to = "value") %>%
    mutate(trend = case_when(
          value >= support ~ "Positive",
          value <= negsupport ~ "Negative",
          TRUE ~ "Neutral")) %>%
    filter(variable=="dominance", trend=="Positive") %>%
    arrange(-value) %>%
    left_join(genome_metadata,by=join_by(genome==genome)) %>%
    select(genome,phylum,class,order,species,value) %>%
    tt()
```

### Negatively associated genomes

```{r negative_table, warning=FALSE, comments="", message=FALSE}
getPostEstimate(hM=m, parName="Beta")$support %>%
    as.data.frame() %>%
    mutate(variable=m$covNames) %>%
    pivot_longer(!variable, names_to = "genome", values_to = "value") %>%
    mutate(trend = case_when(
          value >= support ~ "Positive",
          value <= negsupport ~ "Negative",
          TRUE ~ "Neutral")) %>%
    filter(variable=="dominance", trend=="Negative") %>%
    arrange(value) %>%
    left_join(genome_metadata,by=join_by(genome==genome)) %>%
    select(genome,phylum,class,order,species,value) %>%
    tt()
```

### Estimate - support plot

```{r estimate_support_plot, warning=FALSE, comments="", message=FALSE, fig.height=6, fig.width=10, fig.fullwidth=TRUE}
estimate <- getPostEstimate(hM=m, parName="Beta")$mean %>%
    as.data.frame() %>%
    mutate(variable=m$covNames) %>%
    filter(variable=="dominance") %>%
    pivot_longer(!variable, names_to = "genome", values_to = "mean") %>%
    select(genome,mean)

support <- getPostEstimate(hM=m, parName="Beta")$support %>%
    as.data.frame() %>%
    mutate(variable=m$covNames) %>%
    filter(variable=="dominance") %>%
    pivot_longer(!variable, names_to = "genome", values_to = "support") %>%
    select(genome,support)

phylum_colors <- read_tsv("https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv") %>%
    right_join(genome_metadata, by=join_by(phylum == phylum)) %>%
    filter(genome %in% estimate$genome) %>%
    arrange(match(genome, estimate$genome)) %>%
     select(phylum, colors) %>%
    unique() %>%
    arrange(phylum) %>%
    select(colors) %>%
    pull()

inner_join(estimate,support,by=join_by(genome==genome)) %>%
    mutate(significance=ifelse(support >= 0.9 | support <= 0.1,1,0)) %>%
    mutate(support=ifelse(mean<0,1-support,support)) %>%
    left_join(genome_metadata, by = join_by(genome == genome)) %>%
    mutate(phylum = ifelse(support > 0.9, phylum, NA)) %>%
    ggplot(aes(x=mean,y=support,color=phylum))+
      geom_point(alpha=0.7, shape=16, size=3)+
      scale_color_manual(values = phylum_colors) +
      geom_vline(xintercept = 0) +
      xlim(c(-0.4,0.4)) +
      labs(x = "Beta regression coefficient", y = "Posterior probability") +
      theme_minimal()+
       theme(legend.position = "none")

```

## Predict responses to dominance
Based on the fitted model, we can predict the structure of the microbial community for each level of dominance for a certain value of sequencing depth.

```{r hmsc_predictions, warning=FALSE, comments="", message=FALSE}

# Select modelchain of interest
load("hmsc/fit_model1_250_10.Rdata")

gradient = seq(0,1,0.1)
gradientlength = length(gradient)

#Treatment-specific gradient predictions
pred <- constructGradient(m, 
                      focalVariable = "dominance", 
                      non.focalVariables = list(logseqdepth=list(1)), 
                      ngrid=gradientlength) %>%
             predict(m, Gradient = ., expected = TRUE)

predY <- pred %>%
        do.call(rbind,.) %>%
        as.data.frame() %>%
        mutate(dominance=rep(gradient,1000)) %>%
        pivot_longer(-c(dominance), names_to = "genome", values_to = "value")

```

### Plot responses to dominance
The estimated responses of genomes exhibiting significant positive and negative association with dominance.

```{r hmsc_dominanve_predictions_genomes_plot, warning=FALSE, comments="", message=FALSE, fig.height=8, fig.width=10, fig.fullwidth=TRUE}
# Select desired support threshold
support=0.9
negsupport=1-support

#Get phylum colors from the EHI standard
phylum_colors <- genome_metadata %>%
    left_join(read_tsv("https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv"), by=join_by(phylum == phylum)) %>%
    arrange(match(genome, genome_tree$tip.label)) %>%
    select(phylum, colors) %>%
    unique() %>%
    arrange(phylum) %>%
    #slice(2:5) %>%
    select(colors) %>%
    pull()

getPostEstimate(hM=m, parName="Beta")$support %>%
    as.data.frame() %>%
    mutate(variable=m$covNames) %>%
    pivot_longer(!variable, names_to = "genome", values_to = "value") %>%
    mutate(trend = case_when(
          value >= support ~ "Positive",
          value <= negsupport ~ "Negative",
          TRUE ~ "Neutral")) %>%
    filter(variable=="dominance") %>%
    select(genome,trend) %>%
    left_join(predY, by=join_by(genome==genome)) %>%
    #filter(trend != "Neutral") %>%
    #filter(genome %in% predY_asc)  %>% #only display genomes with contrasting dynamics across treatments
    group_by(genome, trend, dominance) %>%
    summarize(value = mean(value, na.rm = TRUE)) %>%
    left_join(genome_metadata, by=join_by(genome == genome)) %>%
    ggplot(aes(x=dominance, y=value, group=genome, color=phylum, linetype=trend)) + 
        geom_line() +
        scale_linetype_manual(values=c("solid","dashed","solid")) +
        scale_color_manual(values=phylum_colors) +
        facet_grid(fct_rev(trend) ~ phylum) +
        labs(y="Genome abundance (log)",x="Dominance") +
        theme(legend.position = "none") +
        theme_minimal() +
         theme(legend.position = "none",
               axis.text.x = element_text(angle = 45, hjust = 0.8,),
               axis.line.x = element_line(size = 0.5, linetype = "solid", colour = "black"),
)
```

## Plot traits linked to trends

### Test functional trait differences
Using Wilcoxon test with Benjamini-Hochberg procedure for FDR, identify functional traits that differ between genomes that are either positively or negatively association with dominance.

```{r hmsc_dominance_test, warning=FALSE, comments="", message=FALSE, eval=FALSE}
postestimate_test <- getPostEstimate(hM=m, parName="Beta")$support %>%
      as.data.frame() %>%
      mutate(variable=m$covNames) %>%
      pivot_longer(!variable, names_to = "genome", values_to = "value") %>%
      mutate(trend = case_when(
            value >= support ~ "Positive",
            value <= negsupport ~ "Negative",
            TRUE ~ "Neutral")) %>%
      filter(variable=="dominance", trend!="Neutral") %>%
      select(genome,trend) %>%
      left_join(function_table %>% rownames_to_column(var="genome"), by=join_by(genome==genome)) %>%
      pivot_longer(-c(genome,trend), names_to = "trait", values_to = "value") %>%
      group_by(trait) %>%
      summarise(p_value = wilcox.test(value ~ trend)$p.value) %>%
      mutate(p_adjust=p.adjust(p_value, method="BH")) %>%
      filter(p_adjust < 0.05)
```

### Community functional predictions

#### Element level

```{r hmsc_community_element_predictions, warning=FALSE, comments="", message=FALSE}
elements_table <- genome_gifts %>%
    to.elements(., GIFT_db) %>%
    as.data.frame()

community_elements <- predY %>%
  group_by(dominance, genome) %>%
  mutate(row_id = row_number()) %>%
  pivot_wider(names_from = genome, values_from = value) %>%
  ungroup() %>%
  group_split(row_id) %>%
  as.list() %>%
  lapply(., FUN = function(x){x %>%
    select(-row_id) %>%
    column_to_rownames(var = "dominance") %>%
    as.data.frame() %>%
    exp() %>%
    t() %>%
    tss() %>%
    to.community(elements_table,.,GIFT_db) %>% 
    as.data.frame() %>%
    rownames_to_column(var="dominance")
   })
```

```{r hmsc_community_element_predictions_model, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=10, fig.fullwidth=TRUE}
calculate_slope <- function(x) {
  lm_fit <- lm(unlist(x) ~ seq_along(unlist(x)))
  coef(lm_fit)[2]
}

element_predictions <- map_dfc(community_elements, function(mat) {
      mat %>%
        column_to_rownames(var = "dominance") %>%
        t() %>%
        as.data.frame() %>%
        rowwise() %>%
        mutate(slope = calculate_slope(c_across(everything()))) %>%
        select(slope) }) %>%
      t() %>%
      as.data.frame() %>%
      set_names(colnames(community_elements[[1]])[-1]) %>%
      rownames_to_column(var="iteration") %>%
      pivot_longer(!iteration, names_to="trait",values_to="value") %>%
      group_by(trait) %>%
      summarise(mean=mean(value),
        p1 = quantile(value, probs = 0.1),
        p9 = quantile(value, probs = 0.9),
        positive_support = sum(value > 0)/1000,
        negative_support = sum(value < 0)/1000) %>%
      arrange(-positive_support)

# Positively associated
element_predictions %>%
  filter(mean >0) %>%
  arrange(-positive_support) %>%
  tt()

# Negatively associated
element_predictions %>%
  filter(mean <0) %>%
  arrange(-negative_support) %>%
  tt()
```

```{r hmsc_community_element_predictions_plot, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=10, fig.fullwidth=TRUE}
positive <- element_predictions %>%
  filter(mean >0) %>%
  arrange(-positive_support) %>%
  select(-negative_support) %>%
  rename(support=positive_support) %>%
  slice(1:5)

# Negatively associated
negative <- element_predictions %>%
  filter(mean <0) %>%
  arrange(-negative_support) %>%
  select(-positive_support) %>%
  rename(support=negative_support) %>%
  mutate(support=-support) %>%
  slice(1:10) %>%
  arrange(-mean)

bind_rows(positive,negative) %>%
  left_join(GIFT_db,by=join_by(trait==Code_element)) %>%
  mutate(trait=factor(trait,levels=c(rev(positive$trait),negative$trait))) %>%
  ggplot(aes(x=mean, y=fct_rev(trait), xmin=p1, xmax=p9, color=Function)) +
      geom_point() +
      geom_errorbar() +
      scale_color_manual(values = c("#debc14","#440526","#dc7c17","#172742","#357379","#6c7e2c","#d8dc69","#774d35","#db717d")) +
      theme_minimal() +
      labs(x="Regression coefficient",y="Functional trait")
```

#### Function level

```{r hmsc_community_function_predictions, warning=FALSE, comments="", message=FALSE}
functions_table <- elements_table %>%
    to.functions(., GIFT_db) %>%
    as.data.frame()

community_functions <- predY %>%
  group_by(dominance, genome) %>%
  mutate(row_id = row_number()) %>%
  pivot_wider(names_from = genome, values_from = value) %>%
  ungroup() %>%
  group_split(row_id) %>%
  as.list() %>%
  lapply(., FUN = function(x){x %>%
    select(-row_id) %>%
    column_to_rownames(var = "dominance") %>%
    as.data.frame() %>%
    exp() %>%
    t() %>%
    tss() %>%
    to.community(functions_table,.,GIFT_db) %>% 
    as.data.frame() %>%
    rownames_to_column(var="dominance")
   })
```

```{r hmsc_community_function_predictions_model, warning=FALSE, comments="", message=FALSE}
#max-min option
calculate_slope <- function(x) {
  lm_fit <- lm(unlist(x) ~ seq_along(unlist(x)))
  coef(lm_fit)[2]
}

function_predictions <- map_dfc(community_functions, function(mat) {
      mat %>%
        column_to_rownames(var = "dominance") %>%
        t() %>%
        as.data.frame() %>%
        rowwise() %>%
        mutate(slope = calculate_slope(c_across(everything()))) %>%
        select(slope) }) %>%
      t() %>%
      as.data.frame() %>%
      set_names(colnames(community_functions[[1]])[-1]) %>%
      rownames_to_column(var="iteration") %>%
      pivot_longer(!iteration, names_to="trait",values_to="value") %>%
      group_by(trait) %>%
      summarise(mean=mean(value),
        p1 = quantile(value, probs = 0.1),
        p9 = quantile(value, probs = 0.9),
        positive_support = sum(value > 0)/1000,
        negative_support = sum(value < 0)/1000) %>%
      arrange(-positive_support)

# Positively associated
function_predictions %>%
  filter(mean >0) %>%
  arrange(-positive_support) %>%
  tt()

# Negatively associated
function_predictions %>%
  filter(mean <0) %>%
  arrange(-negative_support) %>%
  tt()
```

```{r hmsc_community_function_predictions_model2, warning=FALSE, comments="", message=FALSE, eval=FALSE}
#lm option (incoherent with Bayesian framework)
#function_predictions <- community_functions %>%
#	bind_rows() %>%
#	pivot_longer(-dominance, names_to = "trait", values_to = "value") %>%
#  group_by(trait) %>%
#  mutate(dominance=as.numeric(dominance)) %>%
#  summarize(model=list(lm(value ~ dominance))) %>%
#  ungroup() %>%
#  select(trait,model) %>%
#  mutate(estimate = map_dbl(model, ~broom::tidy(.) %>% filter(term == "dominance") %>% pull(estimate))) %>%
#  mutate(p_value = map_dbl(model, ~broom::tidy(.) %>% filter(term == "dominance") %>% pull(p.value))) %>%
#  mutate(p_value_adj = p.adjust(p_value, method = "bonferroni")) %>%
#  select(-model) %>%
#  arrange(-estimate) %>%
#  filter(p_value_adj < 0.05) 
```

```{r hmsc_community_function_predictions_model3, warning=FALSE, comments="", message=FALSE, eval=FALSE}
#brms option (very lengthy) > even more if group is added as random effect (not in this example)
#function_predictions <- community_functions %>%
#	bind_rows() %>%
#	pivot_longer(-dominance, names_to = "trait", values_to = "value") %>%
#  mutate(dominance=as.numeric(dominance)) %>%
#  group_by(trait) %>%
#  do(model=list(brm(value ~ dominance, data=.))) %>%
#  ungroup() %>%
#  select(trait,model) %>%
#  mutate(estimate = map_dbl(model, ~broom.mixed::tidy(.) %>% filter(term == "dominance") %>% pull(estimate))) %>%
#  mutate(error = map_dbl(model, ~broom.mixed::tidy(.) %>% filter(term == "dominance") %>% pull(std.error))) %>%
#  mutate(error = map_dbl(model, ~broom.mixed::tidy(.) %>% filter(term == "dominance") %>% pull(conf.low))) %>%
#  mutate(error = map_dbl(model, ~broom.mixed::tidy(.) %>% filter(term == "dominance") %>% pull(conf.high))) %>%
#  arrange(-estimate)
```

```{r hmsc_community_function_predictions_plot, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=10, fig.fullwidth=TRUE}
community_functions %>%
	bind_rows() %>%
	pivot_longer(-dominance, names_to = "trait", values_to = "value") %>%
  filter(trait %in% function_predictions$trait) %>%
  mutate(trait=factor(trait, levels=function_predictions$trait)) %>%
	mutate(dominance=as.numeric(dominance)) %>%
   	ggplot(aes(x=dominance, y=value)) +
          geom_smooth(method = lm, formula = y ~ x, se = TRUE) +
          #geom_smooth(method = lm, formula = y ~ splines::bs(x, 3), se = TRUE) +
          facet_wrap(~trait, ncol=5, scales="free") +
          theme_minimal() +
          labs(x="Dominance",y="Metabolic Capacity Index")
```