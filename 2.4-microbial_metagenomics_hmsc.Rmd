---
title: "2.4-microbial_metagenomics_hmsc"
author: "Luisa Santos-Bay & Antton Alberdi"
date: "2024-01-22"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load libraries

```{r libraries, warning=FALSE, comments="", message=FALSE}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(phyloseq))
suppressPackageStartupMessages(library(Hmsc))
suppressPackageStartupMessages(library(distillR))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(ggtree))
suppressPackageStartupMessages(library(ggnewscale))
suppressPackageStartupMessages(library(ggtreeExtra))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(phytools))
suppressPackageStartupMessages(library(hilldiv2))
suppressPackageStartupMessages(library(knitr))
```

## Load data

```{r load_data}
load("data/data.Rdata")
```

## Prepare input for Hmsc
Hmsc requires input object to be formatted in a very specific way. In the following chunk the ramdom effects, fixed effects, read counts and genome phylogeny are declared.


```{r hmsc_input, warning=FALSE, comments="", message=FALSE}
# Random effects data (study design)
StudyDesign <- sample_metadata %>%
                    filter(!is.na(dominance)) %>%
                    select(sample,animal,cage) %>%
                    mutate(cage = factor(cage)) %>%
                    mutate(animal = factor(animal)) %>%
                    distinct() %>%
                    column_to_rownames("sample")

# Genome count table (quantitative community data)
YData <- read_counts  %>%
                    mutate(across(where(is.numeric), ~ . +1 )) %>% #add +1 pseudocount to remove zeros
                    mutate(across(where(is.numeric), ~ . / (genome_metadata$length / 150) )) %>% #transform to genome counts
                    mutate(across(where(is.numeric), ~  log(.) )) %>% #log-transform
                    column_to_rownames("genome") %>%
                    select(all_of(row.names(StudyDesign))) %>%  #filter only faecal samples
                    as.data.frame() %>%
                    t() # transpose

# Fixed effects data (explanatory variables)
XData1 <- sample_metadata %>%
                    filter(sample %in% rownames(StudyDesign)) %>%
                    distinct() %>%
                    select(sample,group,dominance) %>%
                    mutate(logseqdepth=read_counts %>% #total log-sequencing depth
                        select(all_of(row.names(StudyDesign))) %>%
                        colSums() %>%
                        log()
                    ) %>%
                    mutate(group = factor(group)) %>%
                    column_to_rownames("sample")

# Genome phylogeny
PData <- genome_tree
```

## Define formulas of the Hmsc model
Once the input data are ready, it is time for defining the formulas that will structure the model. In our case, the temporal dynamic of microbial communities will be modelled in light of the dominance indices of mice, while adding group (variable or invariable environment) and log-sequencing depth (the sequencing effort per sample) as covariates. Lastly, animal ID and cage ID are declared as random effects to control for the longitudinal aspect of the study (multiple samples per animal) and the housing structure (5 animals per cage).

```{r hmsc_formulas, warning=FALSE, comments="", message=FALSE}

# Fixed effects formula
XFormula1 = ~dominance + group + logseqdepth

# Study design
rL.animal = HmscRandomLevel(units = levels(StudyDesign$animal))
rL.cage = HmscRandomLevel(units = levels(StudyDesign$cage))
```

## Define and Hmsc models
The following chunk generates the Hmsc model that we will later fit in the high computation cluster. In this case there will be a single model called 'model1'.

```{r hmsc_models, warning=FALSE, comments="", message=FALSE}
#Define models
model1 = Hmsc(Y=YData,
         XData = XData1,
         XFormula = XFormula1,
         studyDesign = StudyDesign,
         phyloTree = PData,
         ranLevels = list("animal"=rL.animal, "cage"=rL.cage),
         distr = "normal",
         YScale = TRUE)

#Save list of models as an R object.
model_list = list(model1=model1)
if (!dir.exists("hmsc")){dir.create("hmsc")}
save(model_list, file = "hmsc/hmsc.Rdata")
```


Upload **hmsc/hmsc.Rdata** to the HPC respecting the directory structure.

## Define MCMC
The next step is to define the parameters of the MCMC process for model fitting. In this case we opt for a single number of samplings (250), two thinning values (1 and 10), and 4 chains. This means that once the burn-in part is removed, each of the four MCMC chains will be sampled 250 times either with an interval of 1 or 10 iterations. Note that the 4x250x10 option is about 10 times slower than 4x250x1, although the probability for parameter convergence is increased.

```{r hmsc_mcmc, warning=FALSE, comments="", message=FALSE}
# How often to sample the MCMC
MCMC_samples_list = 250

# The number of MCMC steps between each recording sample
MCMC_thin_list = c(1, 10)

# The number of MCMC chains to use
nChains = 4
```

## Generate Hmsc executables

The next chunk generates shell files for every combination of model, MCMC samples and MCMC thinning, ready to be launched as SLURM jobs. This is because Hmsc requires a notable amount of memory and long computation times, which renders impossible to run most fitting processes in personal computers. 

```{r hmsc_executables, warning=FALSE, comments="", message=FALSE}

modelchains <- expand.grid(model = names(model_list), sample = MCMC_samples_list, thin = MCMC_thin_list)

if (!dir.exists("hmsc")){dir.create("hmsc")}
for(i in c(1:nrow(modelchains))){
      modelname=as.character(modelchains[i,1])
      sample=modelchains[i,2]
      thin=modelchains[i,3]
      executablename <- paste0("hmsc/exe_",modelname,"_",sample,"_",thin,".sh")
      fitname <- paste0("hmsc/fit_",modelname,"_",sample,"_",thin,".Rdata")
      convname <- paste0("hmsc/conv_",modelname,"_",sample,"_",thin,".Rdata")
      model <- paste0('model_list$',modelname)
      psrf.beta.name <-  paste0("psrf.beta.",modelname,"_",sample,"_",thin)
      psrf.gamma.name <-  paste0("psrf.gamma.",modelname,"_",sample,"_",thin)
      psrf.rho.name <-  paste0("psrf.rho.",modelname,"_",sample,"_",thin)
      jobname <- paste0("hmsc_",modelname,"_",sample,"_",thin)
      minutes <- round(sample * thin * (ncol(YData) * nrow(YData)/50000), 0)
      code <- sprintf("#!/bin/bash
#SBATCH --job-name=%s                   # Job name
#SBATCH --nodes=1
#SBATCH --ntasks=4                      # Run on 4 CPUs
#SBATCH --mail-user=antton.alberdi@sund.ku.dk
#SBATCH --mem=800gb                      # Job memory request
#SBATCH --time=%d                       # In minutes

# Activate conda environment
module load mamba/1.3.1
source activate /maps/projects/mjolnir1/people/jpl786/AMAC001_fibre_trial/hmsc/hmsc_env

# Run R script
Rscript -e '
library(tidyverse)
library(Hmsc)
# Load formulas and data
load(\"hmsc/hmsc.Rdata\")

# Declare placeholders
modelname = \"%s\"
model = %s
fitname = \"%s\"
convname = \"%s\"
sample = %d
thin = %d
nchains = %d

# Run model fitting
m = sampleMcmc(hM = model,
         samples = sample,
         thin = thin,
         adaptNf=rep(ceiling(0.4*sample*thin),model$nr),
         transient = ceiling(0.5*sample*thin),
         nChains = nchains,
         nParallel = nchains)

# Assess chain convergence
mpost = convertToCodaObject(m,
      spNamesNumbers = c(T,F),
      covNamesNumbers = c(T,F),
      Beta = TRUE,
      Gamma = TRUE,
      V = FALSE,
      Sigma = FALSE,
      Rho = TRUE,
      Eta = FALSE,
      Lambda = FALSE,
      Alpha = FALSE,
      Omega = FALSE,
      Psi = FALSE,
      Delta = FALSE) # Convert to CODA object

# Fixed effects
assign(paste0(\"psrf.beta.\", modelname,\"_\",sample,\"_\",thin), gelman.diag(mpost$Beta,multivariate=FALSE)$psrf)

# Traits
assign(paste0(\"psrf.gamma.\", modelname,\"_\",sample,\"_\",thin), gelman.diag(mpost$Gamma,multivariate=FALSE)$psrf)

# Phylogeny
assign(paste0(\"psrf.rho.\", modelname,\"_\",sample,\"_\",thin), gelman.diag(mpost$Rho,multivariate=FALSE)$psrf)

# Write convergence data
save(%s, %s, %s, file=convname)

# Save model fit object
save(m, file=fitname)
'
", jobname, minutes, modelname, model, fitname, convname, sample, thin, nChains, psrf.beta.name, psrf.gamma.name, psrf.rho.name)
      writeLines(code, executablename)
    }
```

Upload the produced **hmsc/exe_XXXXX.sh** files to the HPC respecting the directory structure.

## Fit Hmsc models (in Mjolnir HPC)

Launch the SLURM jobs by using:

```{sh, eval=FALSE}
# Submit all .sh files in the hmsc folder
for jobfile in hmsc/exe_*.sh; do
    sbatch "$jobfile"
done

#Or launch them one by one only the ones you want to launch
sbatch hmsc/exe_model1_250_1.sh
sbatch hmsc/exe_model1_250_10.sh
```

When the task is done download the produced **hmsc/conv_XXXXX.Rdata** and **hmsc/fit_XXXXX.Rdata** files to your computer. The 'conv' file only contains the information required for assessing model convergence, while the file 'fit' contains all the information of the fitted model, hence its large size. 

## Assess chain convergence

The 'conv' file is used to assess whether the multiple MCMC chains ran for model fitting converged, i.e., whether all parameters reached similar values. Convergence diagnostic values substantially above 1 indicate lack of convergence, while values below 1.1 are usually considered good enough.

```{r hmsc_convergence, eval=FALSE, warning=FALSE, comments="", message=FALSE}

# Load all conv file available in the hmsc folder
list.files(path = "hmsc", pattern = "^conv_", full.names = TRUE, include.dirs = TRUE) %>%
  lapply(.,load,.GlobalEnv)

# Create a merged psrf.beta (genome) plot
ls() %>%
        grep("^psrf\\.beta", ., value = TRUE) %>%
        map_dfr(~ {
         mat <- get(.x)
          data.frame(modelchain = .x, as.data.frame(mat, , stringsAsFactors = FALSE)) %>%
              rownames_to_column(var="parameter") %>%
              mutate(model = str_split(modelchain, "_") %>% map_chr(1) %>% gsub("psrf.beta.","",.)) %>%
              mutate(sample = str_split(modelchain, "_") %>% map_chr(2)) %>% #extract sample info from model name
              mutate(thin = str_split(modelchain, "_") %>% map_chr(3)) #extract thin info from model name
      }) %>%
      ggplot(.,aes(x=reorder(modelchain,-Point.est.,fun=function(x) {quantile(x, probs = 0.9)}),y=Point.est.)) +
        geom_violin(fill="#b8d9e3", color="#328da8") +
        geom_jitter(alpha=0.3,size=0.2, color="#a8babf") +
        stat_summary(fun=function(x) {quantile(x, probs = 0.9)}, geom="crossbar", width=0.2, color="orange") +
        geom_hline(yintercept=1.1, linetype="dashed", color = "red") +
        ylim(0.9,2)+
        labs(x="Model chains",y="Parameter estimates")+
        theme_classic()

# Create a merged psrf.rho (phylogeny) plot
ls() %>%
        grep("^psrf\\.rho", ., value = TRUE) %>%
        map_dfr(~ {
         mat <- get(.x)
          data.frame(modelchain = .x, as.data.frame(mat, , stringsAsFactors = FALSE)) %>%
              rownames_to_column(var="parameter") %>%
              mutate(model = str_split(modelchain, "_") %>% map_chr(1) %>% gsub("psrf.rho.","",.)) %>%
              mutate(sample = str_split(modelchain, "_") %>% map_chr(2)) %>% #extract sample info from model name
              mutate(thin = str_split(modelchain, "_") %>% map_chr(3)) #extract thin info from model name
      }) %>%
      ggplot(.,aes(x=reorder(modelchain,-Point.est.,fun=function(x) {quantile(x, probs = 0.9)}),y=Point.est.)) +
        geom_violin(fill="#b8d9e3", color="#328da8") +
        geom_jitter(alpha=0.3,size=0.2, color="#a8babf") +
        stat_summary(fun=function(x) {quantile(x, probs = 0.9)}, geom="crossbar", width=0.2, color="orange") +
        geom_hline(yintercept=1.1, linetype="dashed", color = "red") +
        ylim(0.9,2)+
        labs(x="Model chains",y="Parameter estimates")+
        theme_classic()

```
In the beta plot, each dot represents the beta parameter of a different genome, while the dots in the gamma plot indicate different parameters related to phylogeny. We observe that both beta (response to dominance) and rho (phylogenetic signal) parameters display values around 1, with no outliers, indicating that the 4x250x1 model fitting was good enough for our purposes.

## Compute variance partitioning
Once the chain convergence has been validated, we can visualise how the variance of each genome is explained by the different variables employed in the modelling.

```{r hmsc_variancepart, warning=FALSE, comments="", message=FALSE, fig.height=6, fig.width=10, fig.fullwidth=TRUE}

# Select modelchain of interest
load("hmsc/fit_model1_250_1.Rdata")

varpart=computeVariancePartitioning(m)
plotVariancePartitioning(hM=m,VP=varpart)
```

The summary statistics indicate that sequencing depth and the animal random effect explain most of the variation, which highlight the importance of controlling for these features when modelling. There is a substantial cage effect, indicating that the microbiome properties are more alike among cage mates. The two variables that explain the lowest portion of the variance are the experimental group (variable or invariable environment) and dominance index, highlighting that the effect sizes of dominance are rather low.

## Get posterior estimates
The next step is to get the posterior estimates of beta, which is the parameter that links dominance with the microbiome. We employ a support threshold of '0.05' to assign significance, meaning that parameters with posterior overlaps of <10% are considered significantly different.

```{r posterior_estimates, warning=FALSE, comments="", message=FALSE}

support=0.05
supportneg=1-support
  
postestimate <- getPostEstimate(
                  hM=m,
                  parName="Beta")

# Get estimates for dominance
postestimate_support <- postestimate$support %>%
  as.data.frame() %>%
  slice(3) %>%  #select dominance posteriors
  t() %>% 
  as.data.frame() %>%
  rename(posterior=V1) %>%
  mutate(trend = ifelse(posterior < support, "Negative", "Neutral"))  %>%
  mutate(trend = ifelse(posterior > supportneg, "Positive", trend)) %>%
  select(trend)

# Positive
genomes_pos <- postestimate_support %>%
        rownames_to_column(var="genome") %>%
        filter(trend == "Positive") %>%
        select(genome) %>% pull()

# Negative
genomes_neg <- postestimate_support %>%
        rownames_to_column(var="genome") %>%
        filter(trend == "Negative") %>%
        select(genome) %>% pull()

#hmsc built-in function
#plotBeta(hM=m, post=postestimate,supportLevel = 0.95, plotTree=T)
```

### Positively associated genomes

```{r positive_table, warning=FALSE, comments="", message=FALSE}
genome_metadata %>%
    filter(genome %in% genomes_pos) %>%
    select(genome, phylum, order, species, completeness, contamination) %>%
    left_join(postestimate$mean %>%
                  as.data.frame() %>%
                  slice(3) %>% t() %>%
                  as.data.frame() %>%
                  rename(beta=1) %>%
                  rownames_to_column(var="genome"), by=join_by(genome==genome)) %>%
    arrange(-beta) %>%
    kable()
```

### Negatively associated genomes

```{r negative_table, warning=FALSE, comments="", message=FALSE}
genome_metadata %>%
    filter(genome %in% genomes_neg) %>%
    select(genome, phylum, order, species, completeness, contamination) %>%
    left_join(postestimate$mean %>%
                  as.data.frame() %>%
                  slice(3) %>% t() %>%
                  as.data.frame() %>%
                  rename(beta=1) %>%
                  rownames_to_column(var="genome"), by=join_by(genome==genome)) %>%
    arrange(beta) %>%
    kable()
```

## Plot posterior estimates for dominance

```{r posterior_estimates_plot, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=10, fig.fullwidth=TRUE}

#Get phylum colors from the EHI standard
phylum_colors <- genome_metadata %>%
    left_join(read_tsv("https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv"), by=join_by(phylum == phylum)) %>%
    arrange(match(genome, genome_tree$tip.label)) %>%
    select(phylum, colors) %>%
    unique() %>%
    arrange(phylum) %>%
    select(colors) %>%
    pull()

# Generate the phylum color heatmap
phylum_heatmap <- genome_metadata %>%
    left_join(read_tsv("https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv"), by=join_by(phylum == phylum)) %>%
    arrange(match(genome, genome_tree$tip.label)) %>%
    select(genome,phylum) %>%
    mutate(phylum = factor(phylum, levels = unique(phylum))) %>%
    column_to_rownames(var = "genome")

# Aggregate basal GIFT into elements
function_table <- genome_gifts %>%
    to.elements(., GIFT_db) %>%
    as.data.frame()

# Generate  basal tree
function_tree <- force.ultrametric(genome_tree, method="extend") %>%
                ggtree(., size = 0.3) 

#Add phylum colors next to the tree tips
function_tree <- gheatmap(function_tree, phylum_heatmap, offset=0, width=0.1, colnames=FALSE) +
            scale_fill_manual(values=phylum_colors) +
            labs(fill="Phylum") +
            new_scale_fill()

#Add posteriors
function_tree <- gheatmap(function_tree, postestimate_support, offset=0.2, width=0.1, colnames=FALSE)+
            scale_fill_manual(values=c("red","grey","green")) +
            labs(fill="Association with dominance") +
            new_scale_fill()

#Add functions heatmap
function_tree <- gheatmap(function_tree, function_table, offset=0.55, width=3.5, colnames=FALSE) +
            vexpand(.08) +
            coord_cartesian(clip = "off") +
            scale_fill_gradient(low = "#f4f4f4", high = "steelblue", na.value="white") +
            labs(fill="Function fullness")

#Reset fill scale to use a different colour profile in the heatmap
function_tree <- function_tree + new_scale_fill()

# Add completeness barplots
function_tree <- function_tree +
            geom_fruit(data=genome_metadata,
            geom=geom_bar,
            grid.params=list(axis="x", text.size=2, nbreak = 1),
            axis.params=list(vline=TRUE),
            mapping = aes(x=length, y=genome, color=completeness),
                 offset = 3.8,
                 orientation="y",
                 stat="identity") +
            scale_color_gradient(low = "#cf8888", high = "#a2cc87") +
            labs(color="Genome completeness")

function_tree
```

## Predict responses to dominance
Based on the fitted model, we can predict the structure of the microbial community for each level of dominance for a certain value of sequencing depth.

```{r hmsc_predictions, warning=FALSE, comments="", message=FALSE}

# Select modelchain of interest
load("hmsc/fit_model1_250_1.Rdata")

gradient = seq(0,1,0.1)
gradientlength = length(gradient)

#Treatment-specific gradient predictions
pred <- constructGradient(m, 
                      focalVariable = "dominance", 
                      non.focalVariables = list(logseqdepth=list(1)), 
                      ngrid=gradientlength) %>%
             predict(m, Gradient = ., expected = TRUE)

predY <- pred %>%
        do.call(rbind,.) %>%
        as.data.frame() %>%
        mutate(dominance=rep(gradient,1000)) %>%
        pivot_longer(-c(dominance), names_to = "genome", values_to = "value")

```

### Plot responses to dominance
The estimated responses of genomes exhibiting significant positive and negative association with dominance.

```{r hmsc_temporal_predictions_genomes_plot, warning=FALSE, comments="", message=FALSE, fig.height=6, fig.width=10, fig.fullwidth=TRUE}
#Get phylum colors from the EHI standard
phylum_colors <- genome_metadata %>%
    left_join(read_tsv("https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv"), by=join_by(phylum == phylum)) %>%
    arrange(match(genome, genome_tree$tip.label)) %>%
    select(phylum, colors) %>%
    unique() %>%
    arrange(phylum) %>%
    slice(2:6) %>% #remove phyla absent in this chart
    select(colors) %>%
    pull()

postestimate_support %>%
    rownames_to_column(var="genome") %>%
    left_join(predY, by=join_by(genome==genome)) %>%
    filter(trend != "Neutral") %>%
    #filter(genome %in% predY_asc)  %>% #only display genomes with contrasting dynamics across treatments
    group_by(genome, trend, dominance) %>%
    summarize(value = mean(value, na.rm = TRUE)) %>%
    left_join(genome_metadata, by=join_by(genome == genome)) %>%
    ggplot(aes(x=dominance, y=value, group=genome, color=phylum)) + 
        geom_line() +
        scale_color_manual(values=phylum_colors) +
        facet_grid(fct_rev(trend) ~ phylum) +
        labs(y="Genome abundance (log)",x="Dominance") +
        theme(legend.position = "none") +
        theme_minimal() +
         theme(legend.position = "none",
               axis.text.x = element_text(angle = 45, hjust = 0.8,),
               axis.line.x = element_line(size = 0.5, linetype = "solid", colour = "black"),
)
```

## Plot traits linked to trends

### Test functional trait differences
Using Wilcoxon test with Benjamini-Hochberg procedure for FDR, identify functional traits that differ between genomes that are either positively or negatively association with dominance.

```{r hmsc_dominance_test, warning=FALSE, comments="", message=FALSE}
postestimate_test <- postestimate_support %>%
      rownames_to_column(var="genome") %>%
      filter(trend != "Neutral") %>%
      left_join(function_table %>% rownames_to_column(var="genome"), by=join_by(genome==genome)) %>%
      pivot_longer(-c(genome,trend), names_to = "trait", values_to = "value") %>%
      group_by(trait) %>%
      summarise(p_value = wilcox.test(value ~ trend)$p.value) %>%
      mutate(p_adjust=p.adjust(p_value, method="BH")) %>%
      filter(p_adjust < 0.01)
```

### Plot functional trait differences

```{r hmsc_dominance_elements, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=10, fig.fullwidth=TRUE}
postestimate_support %>%
      rownames_to_column(var="genome") %>%
      filter(trend != "Neutral") %>%
      left_join(function_table %>% rownames_to_column(var="genome"), by=join_by(genome==genome)) %>%
      pivot_longer(-c(genome,trend), names_to = "trait", values_to = "value") %>%
      filter(trait %in% postestimate_test$trait) %>% #filter significantly different functions
      filter(trait != "S0201") %>% #remove structural trait
      ggplot(.,aes(x=value, y=trend, fill=trend, color=trend)) +
          #geom_boxplot(color="black") +
          geom_violin() +
          scale_color_manual(values=c("#cf8888","#a2cc87"))+
          scale_fill_manual(values=c("#cf8888","#a2cc87"))+
          facet_grid(trait ~ ., space="free")+
          theme_classic() +
          labs(x="Metabolic Capacity Index",y="Metabolic function", fill="Trend", color="Trend") +
          theme(strip.text.y = element_text(angle = 0),
                  strip.background = element_blank(),
                        axis.text.y=element_blank())
```
### Community functional predictions
```{r hmsc_community_predictions}

function_table2 <- function_table %>% to.functions(., GIFT_db)

community_gifts <- predY %>%
  group_by(dominance, genome) %>%
  mutate(row_id = row_number()) %>%
  pivot_wider(names_from = genome, values_from = value) %>%
  ungroup() %>%
  group_split(row_id) %>%
  as.list() %>%
  lapply(., FUN = function(x){x %>%
    select(-row_id) %>%
    column_to_rownames(var = "dominance") %>%
    as.data.frame() %>%
    exp() %>%
    t() %>%
    tss() %>%
    to.community(function_table2,.,GIFT_db) %>% 
    as.data.frame() %>%
    rownames_to_column(var="dominance")
   })

community_gifts %>%
	bind_rows() %>%
	pivot_longer(-dominance, names_to = "trait", values_to = "value") %>%
	mutate(dominance=as.numeric(dominance)) %>%
	filter(trait=="B0218") %>%
   	ggplot(.,aes(x=dominance, y=value)) +
	  geom_point() +
          geom_smooth(method = lm, formula = y ~ splines::bs(x, 3), se = TRUE) +
          theme_classic() +
          labs(x="Dominance",y="Metabolic Capacity Index") 

community_gifts %>%
	bind_rows() %>%
	pivot_longer(-dominance, names_to = "trait", values_to = "value") %>%
	mutate(dominance=as.numeric(dominance)) %>%
	#filter(trait=="B03") %>%
   	ggplot(.,aes(x=dominance, y=value)) +
	  geom_point() +
          geom_quantile(quantiles = 0.05, formula = y ~ splines::bs(x, 3)) +
          geom_quantile(quantiles = 0.5, formula = y ~ splines::bs(x, 3)) +
          geom_quantile(quantiles = 0.95, formula = y ~ splines::bs(x, 3)) +
          facet_grid(. ~ trait, ) +
          theme_classic() +
          labs(x="Dominance",y="Metabolic Capacity Index") 

```

