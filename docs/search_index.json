[["index.html", "AlberdiLab | Santos-Bay et al. 2024 Hologenomic insights into the social hierachies in mice Chapter 1 Project description 1.1 Prepare the R environment", " AlberdiLab | Santos-Bay et al. 2024 Hologenomic insights into the social hierachies in mice Luisa Santos-Bay1 Tom Gilbert2 Ostaizka Aizpurua3 Antton Alberdi4 2024-03-15 Chapter 1 Project description This webbook contains all the code used for data analysis in study on the hologenomic basis of social hierarchies in laboratory mice. In this study, we analysed the behavioural trait dominance in J:DO laboratory mice (mus musculus) in light of host genomic and microbial metagenomic variation. Over the course of 14 weeks, we measured dominance of 80 mice in total, 40 of each sex, using a tube test to rank the dominance within a cage. Five males or five females were housed together per cage, and a hierarchy of dominance was therefore created ranking the individuals from 1 to 5, where 1 signified “most dominant” and 5 as “most submissive”. We further wanted to explore if the gut microbiome affects dominance under different biological conditions, such as changes in temperature or diet. Hence, the mice were exposed to five specific treatments, all known to interfere with the gut microbiome, each following a four day resting period for the mice to restore the potential unbalance caused (e.g. physiological or gut microbial). The order of treatments was i) an exposure to heat (temperature set to 34 degrees celsius), ii) an exposure to cold (temperature set to 14 degrees celsius), iii) a dietary change, where tryptophan was removed, iv) an antibiotic and antifungal treatment, and lastly, v) a fecal microbiota transplantation, where, among other, the feces from the most dominant animal was given to the most submissive, and vice versa, within each cage. However, two cages - one cage per sex - were not exposed to treatments, and thus, they serve as controls to examine what the gut microbes may have had of influence on dominance without any other biological disturbances. 1.1 Prepare the R environment 1.1.1 Environment To reproduce all the analyses locally, clone this repository in your computer using: RStudio &gt; New Project &gt; Version Control &gt; Git And indicating the following git repository: https://github.com/alberdilab/behavioral_hologenomics.git Once the R project has been created, follow the instructions and code chunks shown in this webbook. 1.1.2 Libraries The following R packages are required for the data analysis. # Base library(R.utils) library(knitr) library(tidyverse) library(devtools) library(tinytable) # For tree handling library(ape) library(phyloseq) library(phytools) # For plotting library(ggplot2) library(ggrepel) library(ggpubr) library(ggnewscale) library(gridExtra) library(ggtreeExtra) library(ggeffects) library(ggtree) library(ggh4x) # For statistics library(GridLMM) library(snpStats) library(qqman) library(Hmsc) library(spaa) library(vegan) library(Rtsne) library(geiger) library(hilldiv2) library(distillR) library(lme4) library(glmmTMB) library(lubridate) library(MuMIn) University of Copenhagen, luisa.nielsen@sund.ku.dk↩︎ University of Copenhagen, t.gilbert@sund.ku.dk↩︎ University of Copenhagen, ostaizka.aizpurua@sund.ku.dk↩︎ University of Copenhagen, antton.alberdi@sund.ku.dk↩︎ "],["data-preparation.html", "Chapter 2 Data preparation", " Chapter 2 Data preparation tube_test_data &lt;- read_csv(&quot;data/tube_tests.csv&quot;) %&gt;% mutate(mouse = substr(mouse, 1, 5)) %&gt;% mutate(cage_id = paste0(&quot;C&quot;, cage_id)) %&gt;% mutate(time = factor(case_when( treatment == &quot;t1&quot; ~ 1, treatment == &quot;t2&quot; ~ 2, treatment == &quot;t3&quot; ~ 3, treatment == &quot;t4&quot; ~ 4, treatment == &quot;t5&quot; ~ 5, treatment == &quot;t6&quot; ~ 6, TRUE ~ NA))) %&gt;% arrange(time) tube_test_data %&gt;% head() %&gt;% tt() |&gt; style_tt(j = 1, color = &quot;#6e0f0f&quot;, background = &quot;#e39d9d&quot;) |&gt; style_tt(i = 0, color = &quot;white&quot;, background = &quot;#a52929&quot;) tinytable_bw4cccggb9i6bvk36tcc .table td.tinytable_css_ykkg7c3pyk0qqjdpkcuv, .table th.tinytable_css_ykkg7c3pyk0qqjdpkcuv { border-bottom: solid 0.1em #d3d8dc; } .table td.tinytable_css_ui1947mjvr5aj7lks2ds, .table th.tinytable_css_ui1947mjvr5aj7lks2ds { color: #6e0f0f; background-color: #e39d9d; } .table td.tinytable_css_b5okty00biyw9dbo52ge, .table th.tinytable_css_b5okty00biyw9dbo52ge { color: white; background-color: #a52929; } trial_id tubetest_id test_number mouse tube_win_position date win_loss_binomial cage_id treatment tube_replicate sex row_number time TT0121 03M_t1_R1 T1 C03M4 A 2/10/2020 0 C03 t1 R1 male 138 1 TT0122 03M_t1_R1 T2 C03M3 B 2/10/2020 0 C03 t1 R1 male 139 1 TT0123 03M_t1_R1 T3 C03M1 A 2/10/2020 0 C03 t1 R1 male 140 1 TT0124 03M_t1_R1 T4 C03M1 B 2/10/2020 0 C03 t1 R1 male 141 1 TT0125 03M_t1_R1 T5 C03M4 B 2/10/2020 0 C03 t1 R1 male 142 1 TT0126 03M_t1_R1 T6 C03M4 A 2/10/2020 0 C03 t1 R1 male 143 1 "],["model-testing.html", "Chapter 3 Model testing 3.1 Model performance 3.2 Model rank", " Chapter 3 Model testing cages=c(&quot;C03&quot;,&quot;C04&quot;,&quot;C05&quot;,&quot;C06&quot;,&quot;C10&quot;,&quot;C11&quot;,&quot;C12&quot;,&quot;C13&quot;) model_performance1 &lt;- data.frame() model_performance2 &lt;- data.frame() for(cage in cages){ #Filter table by cage cage_data &lt;- tube_test_data %&gt;% filter(cage_id == cage) #Model with temporal autocorrelation (NULL if the model does not converge) M1 &lt;- tryCatch({glmmTMB(win_loss_binomial~1+(1|mouse)+(1|treatment:mouse), data = cage_data, family = binomial)}, warning = function(w){NULL}) M2 &lt;- tryCatch({glmmTMB(win_loss_binomial~1+ar1(time+0|mouse)+(1|treatment:mouse), data = cage_data, family = binomial)}, warning = function(w){NULL}) M3 &lt;- tryCatch({glmmTMB(win_loss_binomial~1+ar1(time+0|mouse), data = cage_data, family = binomial)}, warning = function(w){NULL}) M4 &lt;- tryCatch({glmmTMB(win_loss_binomial~1+(1|mouse), data = cage_data, family = binomial)}, warning = function(w){NULL}) M5 &lt;- tryCatch({glmmTMB(win_loss_binomial~1, data = cage_data, family = binomial)}, warning = function(w){NULL}) aic &lt;- c(M1=if(is.null(M1)){NA}else{AIC(M1)}, M2=if(is.null(M2)){NA}else{AIC(M2)}, M3=if(is.null(M3)){NA}else{AIC(M3)}, M4=if(is.null(M4)){NA}else{AIC(M4)}, M5=if(is.null(M5)){NA}else{AIC(M5)}) %&gt;% sort() rank &lt;- names(aic) # Append predictions to table model_performance1 &lt;- bind_rows(model_performance1,rank %&gt;% as.data.frame() %&gt;% t() %&gt;% as.data.frame()) model_performance2 &lt;- bind_rows(model_performance2,aic %&gt;% as.data.frame() %&gt;% t() %&gt;% as.data.frame()) } 3.1 Model performance colnames(model_performance2) &lt;- c(&quot;M1&quot;,&quot;M2&quot;,&quot;M3&quot;,&quot;M4&quot;,&quot;M5&quot;) rownames(model_performance2) &lt;- cages model_performance2 %&gt;% rownames_to_column(var=&quot;Cage&quot;) %&gt;% tt() |&gt; style_tt(j = 1, color = &quot;#6e0f0f&quot;, background = &quot;#e39d9d&quot;) |&gt; style_tt(i = 0, color = &quot;white&quot;, background = &quot;#a52929&quot;) tinytable_ch8uj3zj9fypxzwi42yz .table td.tinytable_css_5y7gvfbctjdrbwniciyi, .table th.tinytable_css_5y7gvfbctjdrbwniciyi { border-bottom: solid 0.1em #d3d8dc; } .table td.tinytable_css_acd4k6x0o3yobnwlofpa, .table th.tinytable_css_acd4k6x0o3yobnwlofpa { color: #6e0f0f; background-color: #e39d9d; } .table td.tinytable_css_8tjpprdva6c171o987i1, .table th.tinytable_css_8tjpprdva6c171o987i1 { color: white; background-color: #a52929; } Cage M1 M2 M3 M4 M5 C03 403.2859 404.1349 405.2859 407.3120 478.8853 C04 483.7269 486.7366 485.7269 493.9658 584.2436 C05 410.3836 415.5269 412.3836 414.9560 575.9259 C06 445.0369 446.3006 447.0369 444.5417 575.9259 C10 423.7239 423.9744 425.7239 421.9744 584.2436 C11 471.6309 481.7121 473.6309 500.8893 581.4710 C12 NA 400.2945 NA 398.2945 584.2436 C13 403.1068 406.1184 405.1068 404.1184 584.2436 3.2 Model rank colnames(model_performance1) &lt;- c(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;) rownames(model_performance1) &lt;- cages model_performance1 %&gt;% rownames_to_column(var=&quot;Cage&quot;) %&gt;% tt() |&gt; style_tt(j = 1, color = &quot;#6e0f0f&quot;, background = &quot;#e39d9d&quot;) |&gt; style_tt(i = 0, color = &quot;white&quot;, background = &quot;#a52929&quot;) tinytable_8n5lyi3auj3ngupl60cv .table td.tinytable_css_qitviz6mz46q1sqc7kff, .table th.tinytable_css_qitviz6mz46q1sqc7kff { border-bottom: solid 0.1em #d3d8dc; } .table td.tinytable_css_1j7s0wptl1dis0ygns12, .table th.tinytable_css_1j7s0wptl1dis0ygns12 { color: #6e0f0f; background-color: #e39d9d; } .table td.tinytable_css_puyt9yekocf86avc0484, .table th.tinytable_css_puyt9yekocf86avc0484 { color: white; background-color: #a52929; } Cage 1 2 3 4 5 C03 M3 M1 M2 M4 M5 C04 M3 M2 M1 M4 M5 C05 M3 M2 M4 M1 M5 C06 M4 M3 M1 M2 M5 C10 M4 M3 M1 M2 M5 C11 M3 M2 M1 M4 M5 C12 M4 M1 M5 NA NA C13 M3 M4 M2 M1 M5 "],["model-prediction.html", "Chapter 4 Model prediction 4.1 Dominance visualisation 4.2 Hierarchy stability", " Chapter 4 Model prediction cages=c(&quot;C03&quot;,&quot;C04&quot;,&quot;C05&quot;,&quot;C06&quot;,&quot;C10&quot;,&quot;C11&quot;,&quot;C12&quot;,&quot;C13&quot;) dominance_predictions &lt;- data.frame() for(cage in cages){ #Filter table by cage cage_data &lt;- tube_test_data %&gt;% filter(cage_id == cage) #Model with temporal autocorrelation (NULL if the model does not converge) M3 &lt;- tryCatch({glmmTMB(win_loss_binomial~1+ar1(time+0|mouse), data = cage_data,family = binomial)}, warning = function(w){NULL}) #Model without temporal autocorrelation M4 &lt;- glmmTMB(win_loss_binomial~1+(1|mouse), data = cage_data,family = binomial) if(!is.null(M3)){ cage_model &lt;- data.frame(ggpredict(M3, type = &quot;random&quot;, terms = c(&quot;mouse&quot;,&quot;time&quot;)), model=&quot;M3&quot;, cage=cage) }else{ cage_model &lt;- data.frame(ggpredict(M4, type = &quot;random&quot;, terms = &quot;mouse&quot;), model=&quot;M4&quot;, cage=cage) cage_model &lt;- bind_rows(cage_model %&gt;% mutate(group = factor(1)), cage_model %&gt;% mutate(group = factor(2)), cage_model %&gt;% mutate(group = factor(3)), cage_model %&gt;% mutate(group = factor(4)), cage_model %&gt;% mutate(group = factor(5)), cage_model %&gt;% mutate(group = factor(6)))} # Append predictions to table dominance_predictions &lt;- bind_rows(dominance_predictions,cage_model) } dominance_predictions &lt;- dominance_predictions %&gt;% mutate(group = factor(case_when( group == 1 ~ &quot;t1&quot;, group == 2 ~ &quot;t2&quot;, group == 3 ~ &quot;t3&quot;, group == 4 ~ &quot;t4&quot;, group == 5 ~ &quot;t5&quot;, group == 6 ~ &quot;t6&quot;, TRUE ~ NA))) %&gt;% rename(mouse=x, dominance=predicted, time=group) 4.1 Dominance visualisation dominance_predictions %&gt;% mutate(time = as.numeric(substr(time, 2, 2))) %&gt;% mutate(mouse_number = substr(mouse, 5, 5)) %&gt;% ggplot(aes(x=time,y=dominance, group=mouse, color=mouse_number)) + geom_line(size=1) + scale_color_manual(values=c(&quot;#D5CFCF&quot;,&quot;#86b9d4&quot;,&quot;#a6897c&quot;,&quot;#2e2e33&quot;,&quot;#2e7287&quot;))+ scale_y_continuous(breaks = c(0,0.25,0.5,0.75,1)) + scale_x_continuous(breaks = c(1:6)) + facet_wrap(cage ~ ., ncol=4) + theme_minimal()+ theme(legend.position = &quot;none&quot;) 4.2 Hierarchy stability cages=c(&quot;C03&quot;,&quot;C04&quot;,&quot;C05&quot;,&quot;C06&quot;,&quot;C10&quot;,&quot;C11&quot;,&quot;C12&quot;,&quot;C13&quot;) hierarchy_stability &lt;- c() for(cage_code in cages){ dominance_predictions_cage &lt;- dominance_predictions %&gt;% filter(cage == cage_code) %&gt;% select(mouse,dominance,time) %&gt;% pivot_wider(names_from=&quot;time&quot;,values_from=&quot;dominance&quot;)%&gt;% select(-mouse) correlation_coefficients &lt;- numeric(length = 5) for (i in 1:5) { correlation_coefficients[i] &lt;- cor(dominance_predictions_cage[, i], dominance_predictions_cage[, i + 1], method = &quot;spearman&quot;) } hierarchy_stability &lt;- c(hierarchy_stability,mean(correlation_coefficients)) } names(hierarchy_stability) &lt;- cages hierarchy_stability %&gt;% as.data.frame() %&gt;% t() %&gt;% as.data.frame() %&gt;% tt(digits = 2) |&gt; style_tt(i = 0, color = &quot;white&quot;, background = &quot;#a52929&quot;) tinytable_3xs5b9etxa5cohwdxdd6 .table td.tinytable_css_hjbpshpxz4b0np5wy4bl, .table th.tinytable_css_hjbpshpxz4b0np5wy4bl { border-bottom: solid 0.1em #d3d8dc; } .table td.tinytable_css_xcbps14lkxoa6e29ouo6, .table th.tinytable_css_xcbps14lkxoa6e29ouo6 { color: white; background-color: #a52929; } C03 C04 C05 C06 C10 C11 C12 C13 0.96 0.86 0.94 0.95 1 0.72 1 1 mean(hierarchy_stability) [1] 0.9292857 sd(hierarchy_stability) [1] 0.09657396 "],["gwas-analysis.html", "Chapter 5 GWAS analysis 5.1 Association analysis", " Chapter 5 GWAS analysis 5.1 Association analysis This step is repeated for each time point separately. # SNP data X = read.plink(&quot;data/variants_filtered.bed&quot;) X = as(X$genotypes,&#39;numeric&#39;) # Metadata data = read_table(&quot;data/dominance_t1.tsv&quot;) %&gt;% mutate(cage=factor(cage)) %&gt;% mutate(mouse=factor(mouse)) %&gt;% as.data.frame() # Run GWAS gwas = GridLMM_GWAS(formula = dominance ~ 1 + (1|cage), test_formula = ~1, reduced_formula = ~0, data = data, X = X, X_ID = &#39;mouse&#39;, method = &#39;REML&#39;, fillNAX = TRUE, verbose = F, mc.cores = 8) 5.1.1 Manhattan plot This step is repeated for each gwas result separately. # Prepare working table gwas_result &lt;- gwas$results %&gt;% #slice_sample(n=100000) %&gt;% separate(X_ID, into = c(&quot;chr&quot;, &quot;bp&quot;), sep = &quot;_&quot;, remove = FALSE) %&gt;% # separate chromosome and position mutate(bp=as.numeric(bp)) %&gt;% mutate(chr=factor(chr, levels=c(c(1:19),&quot;X&quot;))) %&gt;% rename(p=p_value_REML) %&gt;% filter(!is.nan(p)) ### # Custom Manhattan ### # https://r-graph-gallery.com/101_Manhattan_plot.html # Append chromosome coordinates gwas_result &lt;- gwas_result %&gt;% group_by(chr) %&gt;% summarise(chr_len=max(bp)) %&gt;% mutate(tot=cumsum(chr_len)-chr_len) %&gt;% select(-chr_len) %&gt;% left_join(gwas_result, ., by=c(&quot;chr&quot;=&quot;chr&quot;)) %&gt;% arrange(chr, bp) %&gt;% mutate(bp_cum=bp+tot) # Append significance level gwas_result_unsig &lt;- gwas_result %&gt;% filter(p &gt; 0.000001) # Generate chromosome number code axisdf &lt;- gwas_result %&gt;% group_by(chr) %&gt;% summarize(center=mean(bp_cum)) # Plot gwas ggplot(gwas_result_unsig, aes(x=bp_cum, y=-log10(p))) + # Show all points geom_point(aes(color=as.factor(chr)), alpha=0.8, size=1.3) + scale_color_manual(values = rep(c(&quot;grey&quot;, &quot;skyblue&quot;), 22 )) + # Show significant points geom_point(data=gwas_result_sig, aes(x=bp_cum, y=-log10(p)), color=&quot;#FFB91F&quot;, shape=17, alpha=0.9, size=1.6) + # custom X axis: scale_x_continuous(label = axisdf$chr, breaks= axisdf$center, expand = c(0.01, 0.01)) + scale_y_continuous(expand = c(0.01, 0.04)) + # Custom the theme: theme_bw() + labs(x=&quot;Chromosome&quot;) + theme( legend.position=&quot;none&quot;, panel.border = element_blank(), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank() ) Manhattan plot for t3 Manhattan plot for t4 Manhattan plot for t5 Manhattan plot for t6 5.1.2 Candidate gene extraction gwas$results %&gt;% filter(p_value_REML &lt; 0.000001) %&gt;% write.table(., file=&quot;results/gwas_dominance_t1.tsv&quot;, col.names=T, row.names=F, sep=&quot;\\t&quot;, quote=FALSE) "],["candidate-gene-analysis.html", "Chapter 6 Candidate gene analysis", " Chapter 6 Candidate gene analysis # Load SNP tables snps &lt;- bind_rows( read_tsv(&quot;results/gwas_dominance_t1.tsv&quot;) %&gt;% mutate(time=&quot;t1&quot;), read_tsv(&quot;results/gwas_dominance_t2.tsv&quot;) %&gt;% mutate(time=&quot;t2&quot;), read_tsv(&quot;results/gwas_dominance_t3.tsv&quot;) %&gt;% mutate(time=&quot;t3&quot;), read_tsv(&quot;results/gwas_dominance_t4.tsv&quot;) %&gt;% mutate(time=&quot;t4&quot;), read_tsv(&quot;results/gwas_dominance_t5.tsv&quot;) %&gt;% mutate(time=&quot;t5&quot;), read_tsv(&quot;results/gwas_dominance_t6.tsv&quot;) %&gt;% mutate(time=&quot;t6&quot;)) %&gt;% separate(X_ID, into = c(&quot;chr&quot;, &quot;position&quot;), sep = &quot;_&quot;, convert = TRUE) %&gt;% select(-Trait)%&gt;% mutate(chr = as.character(chr)) table(snps$chr) # Load genome annotation annot &lt;- read_tsv(&quot;https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/001/635/GCF_000001635.27_GRCm39/GCF_000001635.27_GRCm39_feature_table.txt.gz&quot;) %&gt;% rename(feature=1) # Merge SNPs and annotation snps_annot &lt;- annot %&gt;% filter(feature == &quot;gene&quot;) %&gt;% select(chromosome, start, end, name, symbol, GeneID) %&gt;% right_join(snps, by = c(&quot;chromosome&quot; = &quot;chr&quot;), relationship = &quot;many-to-many&quot;) %&gt;% filter(position &gt;= start, position &lt;= end) %&gt;% mutate(chromosome = as.numeric(chromosome)) %&gt;% mutate(time = factor(time)) %&gt;% select(time, chromosome, position, name, symbol, GeneID, p_value_REML) %&gt;% arrange(time, chromosome, position) # Number of different features per time snps_annot %&gt;% group_by(time) %&gt;% summarise(features = n_distinct(name), snps=n_distinct(position)) #Number of times per feature snps_annot %&gt;% group_by(symbol) %&gt;% summarise(time = n_distinct(time)) %&gt;% arrange(-time) #Time-progress snps_time &lt;- snps_annot %&gt;% select(symbol,time) %&gt;% mutate(indicator = 1) %&gt;% pivot_wider(names_from = time, values_from = indicator, values_fill = NULL) %&gt;% mutate(across(starts_with(&quot;t&quot;), ~ map_int(., ~ ifelse(is.null(.), 0, length(.))))) snps_time %&gt;% tt() snps_time %&gt;% pivot_longer(!symbol, names_to = &quot;time&quot;, values_to = &quot;value&quot;) %&gt;% mutate(symbol=factor(symbol, levels=rev(snps_time$symbol))) %&gt;% ggplot(aes(y=symbol, x=time, fill=value)) + geom_tile(color = &quot;white&quot;, lwd = 1, linetype = 1) + scale_fill_gradient(low = &quot;white&quot;, high = &quot;#d572ad&quot;) + labs(y=&quot;Genes&quot;, x=&quot;Time&quot;) + theme_classic() # Print the table snps_annot %&gt;% print(n=100) "],["microbiome-data-preparation.html", "Chapter 7 Microbiome data preparation 7.1 Load data 7.2 Filter and normalise data 7.3 Wrap working objects", " Chapter 7 Microbiome data preparation 7.1 Load data 7.1.1 Count table This is the document containing the number of sequencing reads from each sample have been mapped to each MAG. Note that this is the raw data that needs to be further processed before running any statistics on them. read_counts &lt;- read_tsv(&quot;https://sid.erda.dk/share_redirect/CfgcycDTiJ/beho_mgquant/results/stats/coverm_genome_beho_mags.count.tsv&quot;) %&gt;% rename_all(~ str_remove_all(., &quot;.lib1 Read Count&quot;)) %&gt;% #simplify column names rename(genome = 1) Generate a vector of genome names to be employed for filtering and sorting data in downstream steps. genomes &lt;- read_counts$genome # create list of genome names 7.1.2 Base hit table This is the document containing the number of nucleotide bases have been covered by at least one read in each sample and MAG. This information is used to calculate MAG coverage values. basehits &lt;- read_tsv(&quot;https://sid.erda.dk/share_redirect/CfgcycDTiJ/beho_mgquant/results/stats/coverm_genome_beho_mags.covered_bases.tsv&quot;) %&gt;% rename_all(~ str_remove_all(., &quot;.lib1 Covered Bases&quot;)) %&gt;% #simplify column names rename(genome = 1) %&gt;% arrange(match(genome, genomes)) 7.1.3 Sample metadata table dominance_data &lt;- read_tsv(dir(&quot;data&quot;, pattern = &quot;dominance_t\\\\d\\\\.tsv&quot;, full.names = TRUE)) %&gt;% select(-cage) %&gt;% mutate(time = case_when( time == &quot;t1&quot; ~ &quot;OP&quot;, time == &quot;t2&quot; ~ &quot;HT&quot;, time == &quot;t3&quot; ~ &quot;CT&quot;, time == &quot;t4&quot; ~ &quot;DT&quot;, time == &quot;t5&quot; ~ &quot;AN&quot;, time == &quot;t6&quot; ~ &quot;T3&quot;, TRUE ~ NA)) sample_metadata &lt;- read_csv(&quot;https://sid.erda.dk/share_redirect/CfgcycDTiJ/BeHo_sample_metadata.csv&quot;) %&gt;% rename(sample=ERDA_sample_ID) %&gt;% mutate(animal = substr(mouse_ID, 1, 5)) %&gt;% mutate(cage = substr(mouse_ID, 1, 3)) %&gt;% mutate(treatment = substr(sample, 6, 7)) %&gt;% mutate(treatment = ifelse(treatment == &quot;CD&quot;,&quot;CT&quot;,treatment)) %&gt;% mutate(group = ifelse(cage == &quot;C04&quot; | cage == &quot;C13&quot;,&quot;invariable&quot;,&quot;variable&quot;)) %&gt;% select(sample,animal,cage,group,treatment) %&gt;% left_join(dominance_data,by=join_by(animal==mouse, treatment==time)) 7.1.4 Genome metadata Relevant metadata of genomes is fetched from 2-3 files and merged into one genome metadata object for downstream analyses. 7.1.4.1 Genome taxonomy This is the raw taxonomy table generated by GTDBtk, which is simplified for downstream analyses. genome_taxonomy &lt;- read_tsv(&quot;https://sid.erda.dk/share_redirect/CfgcycDTiJ/mag_catalogue_raphael/gtdbtk.bac120.summary.tsv&quot;) %&gt;% rename(genome = user_genome) %&gt;% mutate(genome = str_replace_all(genome,&quot;\\\\.fa&quot;, &quot;&quot;)) %&gt;% separate(classification, c(&quot;domain&quot;,&quot;phylum&quot;,&quot;class&quot;,&quot;order&quot;,&quot;family&quot;,&quot;genus&quot;,&quot;species&quot;), sep =&quot;;&quot;) %&gt;% select(genome,domain,phylum,class,order,family,genus,species) %&gt;% mutate(phylum = case_when( phylum == &quot;p__Firmicutes&quot; ~ &quot;p__Bacillota&quot;, phylum == &quot;p__Firmicutes_A&quot; ~ &quot;p__Bacillota_A&quot;, phylum == &quot;p__Firmicutes_B&quot; ~ &quot;p__Bacillota_B&quot;, phylum == &quot;p__Proteobacteria&quot; ~ &quot;p__Pseudomonadota&quot;, phylum == &quot;p__Actinobacteriota&quot; ~ &quot;p__Actinomycetota&quot;, TRUE ~ phylum)) %&gt;% #Replace phylum names for GTDB r214 taxonomy to match EHI taxonomy colors arrange(match(genome, genomes)) 7.1.4.2 Genome lengths This information is needed to calculate coverage values and to normalise read counts by genome length. genome_lengths &lt;- read_tsv(&quot;https://sid.erda.dk/share_redirect/CfgcycDTiJ/beho_mgquant/results/stats/coverm_genome_beho_mags.length.tsv&quot;) %&gt;% rename(genome=1,length=2) %&gt;% #remove redundancy and rename select(genome,length) 7.1.4.3 Genome quality Quality properties of the genomes. genome_quality &lt;- read_csv(&quot;https://sid.erda.dk/share_redirect/CfgcycDTiJ/mag_catalogue_raphael/checkm_all.csv&quot;) %&gt;% mutate(genome = str_replace_all(genome,&quot;\\\\.fa.gz&quot;, &quot;&quot;)) %&gt;% #remove suffix filter(genome %in% genomes) #retain only dereplicated genomes 7.1.4.4 Merged metadata object Merge taxonomy, length and quality information genome_metadata &lt;- genome_taxonomy %&gt;% left_join(genome_lengths,by=join_by(genome==genome)) %&gt;% #join lengths - not used because Genome quality already contains this information left_join(genome_quality,by=join_by(genome==genome)) #join quality 7.1.5 Genome tree This is the raw tree generated by GTDBtk, which needs to be pruned to obtain the phylogenetic tree of the MAGs. genome_tree &lt;- read.tree(url(&quot;https://sid.erda.dk/share_redirect/CfgcycDTiJ/mag_catalogue_raphael/gtdbtk.backbone.bac120.classify.tree&quot;)) genome_tree$tip.label &lt;- str_replace_all(genome_tree$tip.label,&quot;\\\\.fa&quot;, &quot;&quot;) #remove .fa extension genome_tree &lt;- keep.tip(genome_tree, tip=genomes) # keep only MAG tips 7.1.6 Genome functional annotations This is the raw annotation table generated by DRAM, which is used to generate GIFT data using distillR. genome_annotations &lt;- paste0(&quot;https://sid.erda.dk/share_redirect/CfgcycDTiJ/mag_catalogue_raphael/DRAM_annotations/&quot;,genomes,&quot;_annotations.tsv.gz&quot;) %&gt;% read_tsv() %&gt;% #load all annotations into a single table object rename(gene=1,genome=2) #rename first two columns 7.2 Filter and normalise data Raw data needs to be filtered and normalised to make it useful for downstream analyses. 7.2.1 Generate coverage table By dividing the number of base hits by the length of each genome, coverage values can be calculated. genome_coverage &lt;- basehits %&gt;% mutate(across(where(is.numeric), ~ ./genome_metadata$length)) 7.2.2 Coverage filtering Genomes that have less than 30% of their length covered by reads are turned into zeros to account for the random allocation of reads across genomes due to mapping heuristics. min_coverage=0.3 read_counts_filt &lt;- genome_coverage %&gt;% mutate(across(where(is.numeric), ~ ifelse(. &gt; min_coverage, 1, 0))) %&gt;% mutate(across(-1, ~ . * read_counts[[cur_column()]])) 7.2.3 Generate genome count table After filtering the low-coverage reads, read counts are transformed into genome counts using genome-length and read-length information. readlength=150 #change if sequencing read length is different genome_counts &lt;- read_counts_filt %&gt;% mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength) )) 7.2.4 Distil functional annotations Raw functional annotations are distilled into genome-inferred functional traits to generate biologically more meaningful functional traits for downstream analyses. genome_gifts &lt;- distill(genome_annotations,GIFT_db,genomecol=2,annotcol=c(9,10,19)) 7.3 Wrap working objects In the last step, the objects that are needed for downstream analyses are stored in an R object. save(read_counts, genome_counts, genome_tree, genome_metadata, sample_metadata, genome_gifts, file = &quot;data/data.Rdata&quot;) read_counts: Number of reads mapped to each genome in each sample. Note this is the unfiltered and unnormalised raw community composition table. genome_counts: Number of genomes quantified in each sample, calculated through filtering and normalising read_counts. This is the community composition table to be used in downstream analyses unless otherwise stated. genome_tree: Phylogenetic tree of the genomes, to be employed in downstream phylogenetic analyses. genome_metadata: Taxonomic and quality information of the genomes. genome_gifts: Genome-inferred functional traits of the genomes, to be employed in downstream functional analyses. sample_metadata: Treatment/population and other relevant metadata of the samples. "],["compositional-analysis.html", "Chapter 8 Compositional analysis", " Chapter 8 Compositional analysis load(&quot;data/data.Rdata&quot;) 8.0.1 Genome phylogeny #Get phylum colors from the EHI standard phylum_colors &lt;- genome_metadata %&gt;% left_join(read_tsv(&quot;https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv&quot;), by=join_by(phylum == phylum)) %&gt;% arrange(match(genome, genome_tree$tip.label)) %&gt;% select(phylum, colors) %&gt;% unique() %&gt;% arrange(phylum) %&gt;% select(colors) %&gt;% pull() # Generate the phylum color heatmap phylum_heatmap &lt;- genome_metadata %&gt;% left_join(read_tsv(&quot;https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv&quot;), by=join_by(phylum == phylum)) %&gt;% arrange(match(genome, genome_tree$tip.label)) %&gt;% select(genome,phylum) %&gt;% mutate(phylum = factor(phylum, levels = unique(phylum))) %&gt;% column_to_rownames(var = &quot;genome&quot;) # Generate basal tree circular_tree &lt;- force.ultrametric(genome_tree, method=&quot;extend&quot;) %&gt;% # extend to ultrametric for the sake of visualisation ggtree(., layout=&quot;fan&quot;, open.angle=10, size=0.5) *************************************************************** * Note: * * force.ultrametric does not include a formal method to * * ultrametricize a tree &amp; should only be used to coerce * * a phylogeny that fails is.ultrametric due to rounding -- * * not as a substitute for formal rate-smoothing methods. * *************************************************************** # Add phylum ring circular_tree &lt;- gheatmap(circular_tree, phylum_heatmap, offset=0.40, width=0.1, colnames=FALSE) + scale_fill_manual(values=phylum_colors) + geom_tiplab2(size=1, hjust=-0.1) + theme(legend.position = &quot;none&quot;, plot.margin = margin(0, 0, 0, 0), panel.margin = margin(0, 0, 0, 0)) # Flush color scale to enable a new color scheme in the next ring circular_tree &lt;- circular_tree + new_scale_fill() # Add completeness ring circular_tree &lt;- circular_tree + new_scale_fill() + scale_fill_gradient(low = &quot;#d1f4ba&quot;, high = &quot;#f4baba&quot;) + geom_fruit( data=genome_metadata, geom=geom_bar, mapping = aes(x=completeness, y=genome, fill=contamination), offset = 0.40, orientation=&quot;y&quot;, stat=&quot;identity&quot;) # Add genome-size ring circular_tree &lt;- circular_tree + new_scale_fill() + scale_fill_manual(values = &quot;#cccccc&quot;) + geom_fruit( data=genome_metadata, geom=geom_bar, mapping = aes(x=length, y=genome), offset = 0.05, orientation=&quot;y&quot;, stat=&quot;identity&quot;) # Add text circular_tree &lt;- circular_tree + annotate(&#39;text&#39;, x=2.7, y=0, label=&#39; Phylum&#39;, family=&#39;arial&#39;, size=3.5) + annotate(&#39;text&#39;, x=3.1, y=0, label=&#39; Genome quality&#39;, family=&#39;arial&#39;, size=3.5) + annotate(&#39;text&#39;, x=3.5, y=0, label=&#39; Genome size&#39;, family=&#39;arial&#39;, size=3.5) #Plot circular tree circular_tree %&gt;% open_tree(30) %&gt;% rotate_tree(90) 8.0.2 Genome quality #Completeness genome_metadata %&gt;% summarise(mean=mean(completeness),sd=sd(completeness)) # A tibble: 1 × 2 mean sd &lt;dbl&gt; &lt;dbl&gt; 1 90.9 9.12 #Contamination genome_metadata %&gt;% summarise(mean=mean(contamination),sd=sd(contamination)) # A tibble: 1 × 2 mean sd &lt;dbl&gt; &lt;dbl&gt; 1 1.49 1.77 #Generate quality biplot genome_biplot &lt;- genome_metadata %&gt;% select(c(genome,domain,phylum,completeness,contamination,length)) %&gt;% arrange(match(genome, rev(genome_tree$tip.label))) %&gt;% #sort MAGs according to phylogenetic tree ggplot(aes(x=completeness,y=contamination,size=length,color=phylum)) + geom_point(alpha=0.7) + ylim(c(10,0)) + scale_color_manual(values=phylum_colors) + labs(y= &quot;Contamination&quot;, x = &quot;Completeness&quot;) + theme_classic() + theme(legend.position = &quot;none&quot;) #Generate contamination boxplot genome_contamination &lt;- genome_metadata %&gt;% ggplot(aes(y=contamination)) + ylim(c(10,0)) + geom_boxplot(colour = &quot;#999999&quot;, fill=&quot;#cccccc&quot;) + theme_void() + theme(legend.position = &quot;none&quot;, axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(), plot.margin = unit(c(0, 0, 0.40, 0),&quot;inches&quot;)) #add bottom-margin (top, right, bottom, left) #Generate completeness boxplot genome_completeness &lt;- genome_metadata %&gt;% ggplot(aes(x=completeness)) + xlim(c(50,100)) + geom_boxplot(colour = &quot;#999999&quot;, fill=&quot;#cccccc&quot;) + theme_void() + theme(legend.position = &quot;none&quot;, axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(), plot.margin = unit(c(0, 0, 0, 0.50),&quot;inches&quot;)) #add left-margin (top, right, bottom, left) #Render composite figure grid.arrange(grobs = list(genome_completeness,genome_biplot,genome_contamination), layout_matrix = rbind(c(1,1,1,1,1,1,1,1,1,1,1,4), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3))) 8.0.3 Functional ordination # Aggregate basal GIFT into elements function_table &lt;- genome_gifts %&gt;% to.elements(., GIFT_db) # Generate the tSNE ordination tSNE_function &lt;- Rtsne(X=function_table, dims = 2, check_duplicates = FALSE) # Plot the ordination function_ordination &lt;- tSNE_function$Y %&gt;% as.data.frame() %&gt;% mutate(genome=rownames(function_table)) %&gt;% inner_join(genome_metadata, by=&quot;genome&quot;) %&gt;% rename(tSNE1=&quot;V1&quot;, tSNE2=&quot;V2&quot;) %&gt;% select(genome,phylum,tSNE1,tSNE2, length) %&gt;% ggplot(aes(x = tSNE1, y = tSNE2, color = phylum, size=length))+ geom_point(shape=16, alpha=0.7) + scale_color_manual(values=phylum_colors) + theme_minimal() + labs(color=&quot;Phylum&quot;, size=&quot;Genome size&quot;) + guides(color = guide_legend(override.aes = list(size = 5))) # enlarge Phylum dots in legend function_ordination 8.0.4 Taxonomy barplot per treatment genome_counts %&gt;% mutate_at(vars(-genome),~./sum(.)) %&gt;% #apply TSS nornalisation pivot_longer(-genome, names_to = &quot;sample&quot;, values_to = &quot;count&quot;) %&gt;% #reduce to minimum number of columns left_join(., genome_metadata, by = join_by(genome == genome)) %&gt;% #append genome metadata left_join(., sample_metadata, by = join_by(sample == sample)) %&gt;% #append sample metadata filter(!is.na(count)) %&gt;% filter(!is.na(animal)) %&gt;% filter(cage %in% c(&quot;C03&quot;,&quot;C04&quot;,&quot;C05&quot;,&quot;C06&quot;,&quot;C10&quot;,&quot;C11&quot;,&quot;C12&quot;,&quot;C13&quot;)) %&gt;% mutate(treatment = factor(treatment, levels = c(&quot;OP&quot;,&quot;HT&quot;,&quot;HR&quot;,&quot;CD&quot;,&quot;CR&quot;,&quot;DT&quot;,&quot;DR&quot;,&quot;AN&quot;,&quot;T1&quot;,&quot;T2&quot;,&quot;T3&quot;))) %&gt;% ggplot(., aes(x=count,y=sample, fill=phylum, group=phylum)) + #grouping enables keeping the same sorting of taxonomic units geom_bar(stat=&quot;identity&quot;, colour=&quot;white&quot;, linewidth=0.1) + #plot stacked bars with white borders scale_fill_manual(values=phylum_colors) + labs(y = &quot;Relative abundance&quot;) + facet_nested(cage + treatment ~ ., scales=&quot;free&quot;) + #facet per day and treatment guides(fill = guide_legend(ncol = 1)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), strip.text.y = element_text(angle = 0), axis.title.x = element_blank(), panel.background = element_blank(), panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(linewidth = 0.5, linetype = &quot;solid&quot;, colour = &quot;black&quot;), panel.spacing = unit(0, &quot;lines&quot;)) + labs(fill=&quot;Phylum&quot;) 8.0.5 Taxonomy barplot per individual # Facet groups for coloring facet_boxes &lt;- sample_metadata %&gt;% filter(!is.na(count)) %&gt;% filter(!is.na(animal)) %&gt;% filter(cage %in% c(&quot;C03&quot;,&quot;C04&quot;,&quot;C05&quot;,&quot;C06&quot;,&quot;C10&quot;,&quot;C11&quot;,&quot;C12&quot;,&quot;C13&quot;)) %&gt;% distinct(group,cage,animal) %&gt;% arrange(group,cage) Warning: There was 1 warning in `filter()`. ℹ In argument: `!is.na(count)`. Caused by warning in `is.na()`: ! is.na() applied to non-(list or vector) of type &#39;closure&#39; strip_background &lt;- strip_nested(background_y = elem_list_rect(fill = c( # level1 colors case_match( unique(facet_boxes$group), &quot;invariable&quot; ~ &quot;#ccd47b&quot;, &quot;variable&quot; ~ &quot;#7dacc9&quot;, .default = &quot;grey&quot; ), # level2 colors case_match( unique(facet_boxes$cage), &quot;C04&quot; ~ &quot;#dee3aa&quot;, &quot;C13&quot; ~ &quot;#a7ab7e&quot;, &quot;C03&quot; ~ &quot;#adcde0&quot;, &quot;C05&quot; ~ &quot;#89a0ad&quot;, &quot;C06&quot; ~ &quot;#adcde0&quot;, &quot;C10&quot; ~ &quot;#89a0ad&quot;, &quot;C11&quot; ~ &quot;#adcde0&quot;, &quot;C12&quot; ~ &quot;#89a0ad&quot;, .default = &quot;grey&quot; ), # level3 colors case_match( unique(facet_boxes$animal), &quot;X&quot; ~ &quot;green&quot;, .default = &quot;#f4f4f4&quot; ) ))) genome_counts %&gt;% mutate_at(vars(-genome),~./sum(.)) %&gt;% #apply TSS nornalisation pivot_longer(-genome, names_to = &quot;sample&quot;, values_to = &quot;count&quot;) %&gt;% #reduce to minimum number of columns left_join(., genome_metadata, by = join_by(genome == genome)) %&gt;% #append genome metadata left_join(., sample_metadata, by = join_by(sample == sample)) %&gt;% #append sample metadata filter(!is.na(count)) %&gt;% filter(!is.na(animal)) %&gt;% filter(cage %in% c(&quot;C03&quot;,&quot;C04&quot;,&quot;C05&quot;,&quot;C06&quot;,&quot;C10&quot;,&quot;C11&quot;,&quot;C12&quot;,&quot;C13&quot;)) %&gt;% filter(treatment %in% c(&quot;OP&quot;,&quot;HT&quot;,&quot;HR&quot;,&quot;CT&quot;,&quot;CR&quot;,&quot;DT&quot;,&quot;DR&quot;,&quot;AN&quot;,&quot;T1&quot;,&quot;T2&quot;,&quot;T3&quot;)) %&gt;% mutate(sample = factor(sample, levels = sample_metadata %&gt;% arrange(animal,match(treatment,rev(c(&quot;OP&quot;,&quot;HT&quot;,&quot;HR&quot;,&quot;CT&quot;,&quot;CR&quot;,&quot;DT&quot;,&quot;DR&quot;,&quot;AN&quot;,&quot;T1&quot;,&quot;T2&quot;,&quot;T3&quot;)))) %&gt;% select(sample) %&gt;% filter(!is.na(sample)) %&gt;% pull() )) %&gt;% # sort samples ggplot(., aes(x=count,y=sample, fill=phylum, group=phylum)) + #grouping enables keeping the same sorting of taxonomic units geom_bar(stat=&quot;identity&quot;, colour=&quot;white&quot;, linewidth=0.1) + #plot stacked bars with white borders scale_fill_manual(values=phylum_colors) + labs(x = &quot;Relative abundance&quot;, y =&quot;Samples&quot;) + facet_nested(group + cage + animal ~ ., scales=&quot;free&quot;, strip = strip_background) + #facet per day and treatment guides(fill = guide_legend(ncol = 1)) + scale_x_continuous(expand = c(0.001, 0.001)) + theme(axis.text.y = element_blank(), axis.title.x = element_blank(), strip.text.y = element_text(angle = 0), panel.background = element_blank(), panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(linewidth = 0.5, linetype = &quot;solid&quot;, colour = &quot;black&quot;), panel.spacing = unit(0, &quot;lines&quot;), legend.position = &quot;none&quot;) "],["diversity-analysis.html", "Chapter 9 Diversity analysis 9.1 Alpha diversities 9.2 Define MCMC", " Chapter 9 Diversity analysis load(&quot;data/data.Rdata&quot;) 9.1 Alpha diversities #Calculate Hill numbers richness &lt;- genome_counts %&gt;% column_to_rownames(var=&quot;genome&quot;) %&gt;% select(where(~!all(. == 0))) %&gt;% hilldiv(.,q=0) %&gt;% t() %&gt;% as.data.frame() %&gt;% rename(richness=1) %&gt;% rownames_to_column(var=&quot;sample&quot;) neutral &lt;- genome_counts %&gt;% column_to_rownames(var=&quot;genome&quot;) %&gt;% select(where(~!all(. == 0))) %&gt;% hilldiv(.,q=1) %&gt;% t() %&gt;% as.data.frame() %&gt;% rename(neutral=1) %&gt;% rownames_to_column(var=&quot;sample&quot;) phylogenetic &lt;- genome_counts %&gt;% column_to_rownames(var=&quot;genome&quot;) %&gt;% select(where(~!all(. == 0))) %&gt;% hilldiv(.,q=1,tree=genome_tree) %&gt;% t() %&gt;% as.data.frame() %&gt;% rename(phylogenetic=1) %&gt;% rownames_to_column(var=&quot;sample&quot;) # Aggregate basal GIFT into elements dist &lt;- genome_gifts %&gt;% to.elements(., GIFT_db) %&gt;% traits2dist(., method=&quot;gower&quot;) functional &lt;- genome_counts %&gt;% column_to_rownames(var=&quot;genome&quot;) %&gt;% select(where(~!all(. == 0))) %&gt;% hilldiv(.,q=1,dist=dist) %&gt;% t() %&gt;% as.data.frame() %&gt;% rename(functional=1) %&gt;% rownames_to_column(var=&quot;sample&quot;) %&gt;% mutate(functional = if_else(is.nan(functional), 1, functional)) #Merge into a single table #alpha_div &lt;- cbind(sample=colnames(genome_counts[-1]),richness=q0n,neutral=round(q1n,3),phylo=round(q1p,3),func=round(q1f,3)) %&gt;% alpha_div &lt;- richness %&gt;% full_join(neutral,by=join_by(sample==sample)) %&gt;% full_join(phylogenetic,by=join_by(sample==sample)) %&gt;% full_join(functional,by=join_by(sample==sample)) %&gt;% pivot_longer(-sample, names_to = &quot;metric&quot;, values_to = &quot;diversity&quot;) %&gt;% left_join(., sample_metadata, by = join_by(sample == sample)) %&gt;% filter(cage %in% c(&quot;C03&quot;,&quot;C04&quot;,&quot;C05&quot;,&quot;C06&quot;,&quot;C10&quot;,&quot;C11&quot;,&quot;C12&quot;,&quot;C13&quot;)) %&gt;% mutate(diversity = as.numeric(diversity)) %&gt;% mutate(metric = factor(metric, levels = c(&quot;richness&quot;,&quot;neutral&quot;,&quot;phylogenetic&quot;,&quot;functional&quot;))) #sort metrics alpha_div %&gt;% filter(metric == &quot;richness&quot;) %&gt;% lmerTest::lmer(diversity ~ dominance + group + (1 | animal) + (1 | cage), data = ., REML = FALSE) %&gt;% summary() boundary (singular) fit: see help(&#39;isSingular&#39;) Linear mixed model fit by maximum likelihood . t-tests use Satterthwaite&#39;s method [&#39;lmerModLmerTest&#39;] Formula: diversity ~ dominance + group + (1 | animal) + (1 | cage) Data: . AIC BIC logLik deviance df.resid 2128.2 2148.4 -1058.1 2116.2 210 Scaled residuals: Min 1Q Median 3Q Max -2.94196 -0.42123 0.09392 0.54104 2.55048 Random effects: Groups Name Variance Std.Dev. animal (Intercept) 71.62 8.463 cage (Intercept) 0.00 0.000 Residual 990.74 31.476 Number of obs: 216, groups: animal, 39; cage, 8 Fixed effects: Estimate Std. Error df t value Pr(&gt;|t|) (Intercept) 84.779 6.559 41.660 12.926 3.6e-16 *** dominance 17.870 8.793 48.704 2.032 0.0476 * groupvariable -15.273 5.702 38.397 -2.679 0.0108 * --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Correlation of Fixed Effects: (Intr) domnnc dominance -0.671 groupvaribl -0.634 0.001 optimizer (nloptwrap) convergence code: 0 (OK) boundary (singular) fit: see help(&#39;isSingular&#39;) alpha_div %&gt;% filter(metric == &quot;neutral&quot;) %&gt;% lmerTest::lmer(diversity ~ dominance + group + (1 | animal) + (1 | cage), data = ., REML = FALSE) %&gt;% summary() boundary (singular) fit: see help(&#39;isSingular&#39;) Linear mixed model fit by maximum likelihood . t-tests use Satterthwaite&#39;s method [&#39;lmerModLmerTest&#39;] Formula: diversity ~ dominance + group + (1 | animal) + (1 | cage) Data: . AIC BIC logLik deviance df.resid 1693.9 1714.1 -840.9 1681.9 210 Scaled residuals: Min 1Q Median 3Q Max -2.33081 -0.59501 0.03916 0.64883 2.56233 Random effects: Groups Name Variance Std.Dev. animal (Intercept) 0 0.00 cage (Intercept) 0 0.00 Residual 141 11.87 Number of obs: 216, groups: animal, 39; cage, 8 Fixed effects: Estimate Std. Error df t value Pr(&gt;|t|) (Intercept) 28.686 2.088 216.000 13.739 &lt;2e-16 *** dominance 4.100 2.834 216.000 1.446 0.1495 groupvariable -4.028 1.804 216.000 -2.233 0.0266 * --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Correlation of Fixed Effects: (Intr) domnnc dominance -0.679 groupvaribl -0.626 0.003 optimizer (nloptwrap) convergence code: 0 (OK) boundary (singular) fit: see help(&#39;isSingular&#39;) alpha_div %&gt;% filter(metric == &quot;phylogenetic&quot;) %&gt;% lmerTest::lmer(dominance ~ diversity + group + (1 | animal) + (1 | cage), data = ., REML = FALSE) %&gt;% summary() boundary (singular) fit: see help(&#39;isSingular&#39;) Linear mixed model fit by maximum likelihood . t-tests use Satterthwaite&#39;s method [&#39;lmerModLmerTest&#39;] Formula: dominance ~ diversity + group + (1 | animal) + (1 | cage) Data: . AIC BIC logLik deviance df.resid -310.9 -290.6 161.4 -322.9 210 Scaled residuals: Min 1Q Median 3Q Max -4.8063 -0.3472 0.0156 0.2933 2.7098 Random effects: Groups Name Variance Std.Dev. animal (Intercept) 0.074930 0.27373 cage (Intercept) 0.000000 0.00000 Residual 0.006122 0.07824 Number of obs: 216, groups: animal, 39; cage, 8 Fixed effects: Estimate Std. Error df t value Pr(&gt;|t|) (Intercept) 4.745e-01 9.055e-02 4.525e+01 5.241 4.06e-06 *** diversity 5.659e-03 5.422e-03 1.785e+02 1.044 0.298 groupvariable 2.169e-03 1.011e-01 3.894e+01 0.021 0.983 --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Correlation of Fixed Effects: (Intr) dvrsty diversity -0.271 groupvaribl -0.829 -0.005 optimizer (nloptwrap) convergence code: 0 (OK) boundary (singular) fit: see help(&#39;isSingular&#39;) alpha_div %&gt;% filter(metric == &quot;functional&quot;) %&gt;% lmerTest::lmer(dominance ~ diversity + group + (1 | animal) + (1 | cage), data = ., REML = FALSE) %&gt;% summary() boundary (singular) fit: see help(&#39;isSingular&#39;) Linear mixed model fit by maximum likelihood . t-tests use Satterthwaite&#39;s method [&#39;lmerModLmerTest&#39;] Formula: dominance ~ diversity + group + (1 | animal) + (1 | cage) Data: . AIC BIC logLik deviance df.resid -311.8 -291.5 161.9 -323.8 210 Scaled residuals: Min 1Q Median 3Q Max -4.7854 -0.3173 0.0196 0.3444 2.6510 Random effects: Groups Name Variance Std.Dev. animal (Intercept) 0.07500 0.27387 cage (Intercept) 0.00000 0.00000 Residual 0.00609 0.07804 Number of obs: 216, groups: animal, 39; cage, 8 Fixed effects: Estimate Std. Error df t value Pr(&gt;|t|) (Intercept) 3.849e-01 1.195e-01 1.171e+02 3.22 0.00166 ** diversity 8.293e-02 5.880e-02 1.779e+02 1.41 0.16018 groupvariable 3.035e-03 1.011e-01 3.894e+01 0.03 0.97621 --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Correlation of Fixed Effects: (Intr) dvrsty diversity -0.684 groupvaribl -0.631 0.003 optimizer (nloptwrap) convergence code: 0 (OK) boundary (singular) fit: see help(&#39;isSingular&#39;) alpha_div %&gt;% filter(metric == &quot;richness&quot;) %&gt;% filter(treatment != &quot;AN&quot;) %&gt;% ggplot(aes(x=dominance, y=diversity, group=cage)) + geom_point()+ geom_smooth(method=lm , color=&quot;red&quot;, fill=&quot;#69b3a2&quot;, se=TRUE) + facet_nested(. ~ group + cage) + theme_minimal() + theme(axis.text.x = element_blank()) + labs(y=&quot;Richness&quot;) alpha_div %&gt;% filter(metric == &quot;neutral&quot;) %&gt;% filter(treatment != &quot;AN&quot;) %&gt;% ggplot(aes(x=dominance, y=diversity, group=cage)) + geom_point()+ geom_smooth(method=lm , color=&quot;red&quot;, fill=&quot;#69b3a2&quot;, se=TRUE) + facet_nested(. ~ group + cage) + theme_minimal() + theme(axis.text.x = element_blank()) + labs(y=&quot;Neutral diversity&quot;) alpha_div %&gt;% filter(metric == &quot;phylogenetic&quot;) %&gt;% filter(treatment != &quot;AN&quot;) %&gt;% ggplot(aes(x=dominance, y=diversity, group=cage)) + geom_point()+ geom_smooth(method=lm , color=&quot;red&quot;, fill=&quot;#69b3a2&quot;, se=TRUE) + facet_nested(. ~ group + cage) + theme_minimal() + theme(axis.text.x = element_blank()) + labs(y=&quot;Phylogenetic diversity&quot;) alpha_div %&gt;% filter(metric == &quot;functional&quot;) %&gt;% filter(treatment != &quot;AN&quot;) %&gt;% ggplot(aes(x=dominance, y=diversity, group=cage)) + geom_point()+ geom_smooth(method=lm , color=&quot;red&quot;, fill=&quot;#69b3a2&quot;, se=TRUE) + facet_nested(. ~ group + cage) + theme_minimal() + theme(axis.text.x = element_blank()) + labs(y=&quot;Functional diversity&quot;) #Plot diversities alpha_plot_neutral &lt;- alpha_div %&gt;% filter(metric==&quot;neutral&quot;) %&gt;% mutate(sample = factor(sample, levels = sample_metadata %&gt;% arrange(animal,match(treatment,rev(c(&quot;OP&quot;,&quot;HT&quot;,&quot;HR&quot;,&quot;CT&quot;,&quot;CR&quot;,&quot;DT&quot;,&quot;DR&quot;,&quot;AN&quot;,&quot;T1&quot;,&quot;T2&quot;,&quot;T3&quot;)))) %&gt;% select(sample) %&gt;% filter(!is.na(sample)) %&gt;% pull() )) %&gt;% # sort samples filter(!is.na(animal)) %&gt;% ggplot(aes(x=diversity, y=sample)) + geom_bar(stat=&#39;identity&#39;, fill=&quot;#6c9ebc&quot;) + facet_nested(group + cage + animal ~ metric, scales=&quot;free&quot;) + #facet per treatment and animal coord_cartesian(xlim = c(1, NA)) + theme_classic() + theme( strip.background = element_blank(), panel.grid.minor.x = element_line( size=.1, color=&quot;grey&quot; ), axis.title.y = element_blank(), axis.title.x = element_blank(), axis.text.y = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), strip.text.y = element_blank() ) alpha_plot_phylo &lt;- alpha_div %&gt;% filter(metric==&quot;phylogenetic&quot;) %&gt;% mutate(sample = factor(sample, levels = sample_metadata %&gt;% arrange(animal,match(treatment,rev(c(&quot;OP&quot;,&quot;HT&quot;,&quot;HR&quot;,&quot;CT&quot;,&quot;CR&quot;,&quot;DT&quot;,&quot;DR&quot;,&quot;AN&quot;,&quot;T1&quot;,&quot;T2&quot;,&quot;T3&quot;)))) %&gt;% select(sample) %&gt;% filter(!is.na(sample)) %&gt;% pull() )) %&gt;% # sort samples filter(!is.na(animal)) %&gt;% ggplot(aes(x=diversity, y=sample)) + geom_bar(stat=&#39;identity&#39;, fill=&quot;#6c9ebc&quot;) + facet_nested(group + cage + animal ~ metric, scales=&quot;free&quot;) + #facet per treatment and animal coord_cartesian(xlim = c(1, NA)) + theme_classic() + theme( strip.background = element_blank(), panel.grid.minor.x = element_line( size=.1, color=&quot;grey&quot; ), axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text.y = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), strip.text.y = element_blank() ) alpha_plot_func &lt;- alpha_div %&gt;% filter(metric==&quot;functional&quot;) %&gt;% mutate(sample = factor(sample, levels = sample_metadata %&gt;% arrange(animal,match(treatment,rev(c(&quot;OP&quot;,&quot;HT&quot;,&quot;HR&quot;,&quot;CT&quot;,&quot;CR&quot;,&quot;DT&quot;,&quot;DR&quot;,&quot;AN&quot;,&quot;T1&quot;,&quot;T2&quot;,&quot;T3&quot;)))) %&gt;% select(sample) %&gt;% filter(!is.na(sample)) %&gt;% pull() )) %&gt;% # sort samples filter(!is.na(animal)) %&gt;% ggplot(aes(x=diversity, y=sample)) + geom_bar(stat=&#39;identity&#39;, fill=&quot;#6c9ebc&quot;) + facet_nested(group + cage + animal ~ metric, scales=&quot;free&quot;) + #facet per treatment and animal coord_cartesian(xlim = c(1, NA)) + theme_classic() + theme(strip.text.y = element_text(angle = 0), axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text.y = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1) ) grid.arrange(alpha_plot_neutral, alpha_plot_phylo, alpha_plot_func, nrow = 1) #Calculate Hill numbers beta_neutral &lt;- genome_counts %&gt;% column_to_rownames(var=&quot;genome&quot;) %&gt;% hillpair(.,q=1, metric=&quot;C&quot;) &lt;!--chapter:end:05_microbiome_diversity.Rmd--&gt; # Dominance-microbiome modelling load(&quot;data/data.Rdata&quot;) 9.1.1 HMSC modelling 9.1.2 Prepare input for Hmsc Hmsc requires input object to be formatted in a very specific way. In the following chunk the random effects, fixed effects, read counts and genome phylogeny are declared. # Random effects data (study design) StudyDesign &lt;- sample_metadata %&gt;% filter(!is.na(dominance)) %&gt;% select(sample,animal,cage) %&gt;% mutate(cage = factor(cage)) %&gt;% mutate(animal = factor(animal)) %&gt;% distinct() %&gt;% column_to_rownames(&quot;sample&quot;) # Genome count table (quantitative community data) YData &lt;- read_counts %&gt;% select(all_of(c(&quot;genome&quot;,rownames(StudyDesign)))) %&gt;% mutate(across(where(is.numeric), ~ . +1 )) %&gt;% #add +1 pseudocount to remove zeros mutate(across(where(is.numeric), ~ . / (genome_metadata$length / 150) )) %&gt;% #transform to genome counts mutate(across(where(is.numeric), ~ log(.) )) %&gt;% #log-transform column_to_rownames(&quot;genome&quot;) %&gt;% select(all_of(row.names(StudyDesign))) %&gt;% #filter only faecal samples as.data.frame() %&gt;% t() # transpose # Fixed effects data (explanatory variables) XData &lt;- sample_metadata %&gt;% filter(sample %in% rownames(StudyDesign)) %&gt;% distinct() %&gt;% select(sample,group,dominance) %&gt;% mutate(logseqdepth=read_counts %&gt;% #total log-sequencing depth select(all_of(row.names(StudyDesign))) %&gt;% colSums() %&gt;% log() ) %&gt;% mutate(group = factor(group)) %&gt;% column_to_rownames(&quot;sample&quot;) # Genome phylogeny PData &lt;- genome_tree 9.1.3 Define formulas of the Hmsc model Once the input data are ready, it is time for defining the formulas that will structure the model. In our case, the temporal dynamic of microbial communities will be modelled in light of the dominance indices of mice, while adding group (variable or invariable environment) and log-sequencing depth (the sequencing effort per sample) as covariates. Lastly, animal ID and cage ID are declared as random effects to control for the longitudinal aspect of the study (multiple samples per animal) and the housing structure (5 animals per cage). # Fixed effects formula XFormula1 = ~dominance + group + logseqdepth # Study design rL.animal = HmscRandomLevel(units = levels(StudyDesign$animal)) rL.cage = HmscRandomLevel(units = levels(StudyDesign$cage)) 9.1.4 Define and Hmsc models The following chunk generates the Hmsc model that we will later fit in the high computation cluster. In this case there will be a single model called ‘model1’. #Define models model1 = Hmsc(Y=YData, XData = XData, XFormula = XFormula1, studyDesign = StudyDesign, phyloTree = PData, ranLevels = list(&quot;animal&quot;=rL.animal, &quot;cage&quot;=rL.cage), distr = &quot;normal&quot;, YScale = TRUE) #Save list of models as an R object. model_list = list(model1=model1) if (!dir.exists(&quot;hmsc&quot;)){dir.create(&quot;hmsc&quot;)} save(model_list, file = &quot;hmsc/hmsc.Rdata&quot;) Upload hmsc/hmsc.Rdata to the HPC respecting the directory structure. 9.2 Define MCMC The next step is to define the parameters of the MCMC process for model fitting. In this case we opt for a single number of samplings (250), two thinning values (1 and 10), and 4 chains. This means that once the burn-in part is removed, each of the four MCMC chains will be sampled 250 times either with an interval of 1 or 10 iterations. Note that the 4x250x10 option is about 10 times slower than 4x250x1, although the probability for parameter convergence is increased. # How often to sample the MCMC MCMC_samples_list = 250 # The number of MCMC steps between each recording sample MCMC_thin_list = c(1, 10) # The number of MCMC chains to use nChains = 4 9.2.1 Generate Hmsc executables The next chunk generates shell files for every combination of model, MCMC samples and MCMC thinning, ready to be launched as SLURM jobs. This is because Hmsc requires a notable amount of memory and long computation times, which renders impossible to run most fitting processes in personal computers. modelchains &lt;- expand.grid(model = names(model_list), sample = MCMC_samples_list, thin = MCMC_thin_list) if (!dir.exists(&quot;hmsc&quot;)){dir.create(&quot;hmsc&quot;)} for(i in c(1:nrow(modelchains))){ modelname=as.character(modelchains[i,1]) sample=modelchains[i,2] thin=modelchains[i,3] executablename &lt;- paste0(&quot;hmsc/exe_&quot;,modelname,&quot;_&quot;,sample,&quot;_&quot;,thin,&quot;.sh&quot;) fitname &lt;- paste0(&quot;hmsc/fit_&quot;,modelname,&quot;_&quot;,sample,&quot;_&quot;,thin,&quot;.Rdata&quot;) convname &lt;- paste0(&quot;hmsc/conv_&quot;,modelname,&quot;_&quot;,sample,&quot;_&quot;,thin,&quot;.Rdata&quot;) model &lt;- paste0(&#39;model_list$&#39;,modelname) psrf.beta.name &lt;- paste0(&quot;psrf.beta.&quot;,modelname,&quot;_&quot;,sample,&quot;_&quot;,thin) psrf.gamma.name &lt;- paste0(&quot;psrf.gamma.&quot;,modelname,&quot;_&quot;,sample,&quot;_&quot;,thin) psrf.rho.name &lt;- paste0(&quot;psrf.rho.&quot;,modelname,&quot;_&quot;,sample,&quot;_&quot;,thin) jobname &lt;- paste0(&quot;hmsc_&quot;,modelname,&quot;_&quot;,sample,&quot;_&quot;,thin) minutes &lt;- round(sample * thin * (ncol(YData) * nrow(YData)/50000), 0) code &lt;- sprintf(&quot;#!/bin/bash #SBATCH --job-name=%s # Job name #SBATCH --nodes=1 #SBATCH --ntasks=4 # Run on 4 CPUs #SBATCH --mail-user=antton.alberdi@sund.ku.dk #SBATCH --mem=800gb # Job memory request #SBATCH --time=%d # In minutes # Activate conda environment module load mamba/1.3.1 source activate /maps/projects/mjolnir1/people/jpl786/AMAC001_fibre_trial/hmsc/hmsc_env # Run R script Rscript -e &#39; library(tidyverse) library(Hmsc) # Load formulas and data load(\\&quot;hmsc/hmsc.Rdata\\&quot;) # Declare placeholders modelname = \\&quot;%s\\&quot; model = %s fitname = \\&quot;%s\\&quot; convname = \\&quot;%s\\&quot; sample = %d thin = %d nchains = %d # Run model fitting m = sampleMcmc(hM = model, samples = sample, thin = thin, adaptNf=rep(ceiling(0.4*sample*thin),model$nr), transient = ceiling(0.5*sample*thin), nChains = nchains, nParallel = nchains) # Assess chain convergence mpost = convertToCodaObject(m, spNamesNumbers = c(T,F), covNamesNumbers = c(T,F), Beta = TRUE, Gamma = TRUE, V = FALSE, Sigma = FALSE, Rho = TRUE, Eta = FALSE, Lambda = FALSE, Alpha = FALSE, Omega = FALSE, Psi = FALSE, Delta = FALSE) # Convert to CODA object # Fixed effects assign(paste0(\\&quot;psrf.beta.\\&quot;, modelname,\\&quot;_\\&quot;,sample,\\&quot;_\\&quot;,thin), gelman.diag(mpost$Beta,multivariate=FALSE)$psrf) # Traits assign(paste0(\\&quot;psrf.gamma.\\&quot;, modelname,\\&quot;_\\&quot;,sample,\\&quot;_\\&quot;,thin), gelman.diag(mpost$Gamma,multivariate=FALSE)$psrf) # Phylogeny assign(paste0(\\&quot;psrf.rho.\\&quot;, modelname,\\&quot;_\\&quot;,sample,\\&quot;_\\&quot;,thin), gelman.diag(mpost$Rho,multivariate=FALSE)$psrf) # Write convergence data save(%s, %s, %s, file=convname) # Save model fit object save(m, file=fitname) &#39; &quot;, jobname, minutes, modelname, model, fitname, convname, sample, thin, nChains, psrf.beta.name, psrf.gamma.name, psrf.rho.name) writeLines(code, executablename) } Upload the produced hmsc/exe_XXXXX.sh files to the HPC respecting the directory structure. 9.2.2 Fit Hmsc models (in Mjolnir HPC) Launch the SLURM jobs by using: # Submit all .sh files in the hmsc folder for jobfile in hmsc/exe_*.sh; do sbatch &quot;$jobfile&quot; done #Or launch them one by one only the ones you want to launch sbatch hmsc/exe_model1_250_1.sh sbatch hmsc/exe_model1_250_10.sh When the task is done download the produced hmsc/conv_XXXXX.Rdata and hmsc/fit_XXXXX.Rdata files to your computer. The ‘conv’ file only contains the information required for assessing model convergence, while the file ‘fit’ contains all the information of the fitted model, hence its large size. 9.2.3 Assess chain convergence The ‘conv’ file is used to assess whether the multiple MCMC chains ran for model fitting converged, i.e., whether all parameters reached similar values. Convergence diagnostic values substantially above 1 indicate lack of convergence, while values below 1.1 are usually considered good enough. # Load all conv file available in the hmsc folder list.files(path = &quot;hmsc&quot;, pattern = &quot;^conv_&quot;, full.names = TRUE, include.dirs = TRUE) %&gt;% lapply(.,load,.GlobalEnv) # Create a merged psrf.beta (genome) plot ls() %&gt;% grep(&quot;^psrf\\\\.beta&quot;, ., value = TRUE) %&gt;% map_dfr(~ { mat &lt;- get(.x) data.frame(modelchain = .x, as.data.frame(mat, , stringsAsFactors = FALSE)) %&gt;% rownames_to_column(var=&quot;parameter&quot;) %&gt;% mutate(model = str_split(modelchain, &quot;_&quot;) %&gt;% map_chr(1) %&gt;% gsub(&quot;psrf.beta.&quot;,&quot;&quot;,.)) %&gt;% mutate(sample = str_split(modelchain, &quot;_&quot;) %&gt;% map_chr(2)) %&gt;% #extract sample info from model name mutate(thin = str_split(modelchain, &quot;_&quot;) %&gt;% map_chr(3)) #extract thin info from model name }) %&gt;% ggplot(.,aes(x=reorder(modelchain,-Point.est.,fun=function(x) {quantile(x, probs = 0.9)}),y=Point.est.)) + geom_violin(fill=&quot;#b8d9e3&quot;, color=&quot;#328da8&quot;) + geom_jitter(alpha=0.3,size=0.2, color=&quot;#a8babf&quot;) + stat_summary(fun=function(x) {quantile(x, probs = 0.9)}, geom=&quot;crossbar&quot;, width=0.2, color=&quot;orange&quot;) + geom_hline(yintercept=1.1, linetype=&quot;dashed&quot;, color = &quot;red&quot;) + ylim(0.9,2)+ labs(x=&quot;Model chains&quot;,y=&quot;Parameter estimates&quot;)+ theme_classic() # Create a merged psrf.rho (phylogeny) plot ls() %&gt;% grep(&quot;^psrf\\\\.rho&quot;, ., value = TRUE) %&gt;% map_dfr(~ { mat &lt;- get(.x) data.frame(modelchain = .x, as.data.frame(mat, , stringsAsFactors = FALSE)) %&gt;% rownames_to_column(var=&quot;parameter&quot;) %&gt;% mutate(model = str_split(modelchain, &quot;_&quot;) %&gt;% map_chr(1) %&gt;% gsub(&quot;psrf.rho.&quot;,&quot;&quot;,.)) %&gt;% mutate(sample = str_split(modelchain, &quot;_&quot;) %&gt;% map_chr(2)) %&gt;% #extract sample info from model name mutate(thin = str_split(modelchain, &quot;_&quot;) %&gt;% map_chr(3)) #extract thin info from model name }) %&gt;% ggplot(.,aes(x=reorder(modelchain,-Point.est.,fun=function(x) {quantile(x, probs = 0.9)}),y=Point.est.)) + geom_violin(fill=&quot;#b8d9e3&quot;, color=&quot;#328da8&quot;) + geom_jitter(alpha=0.3,size=0.2, color=&quot;#a8babf&quot;) + stat_summary(fun=function(x) {quantile(x, probs = 0.9)}, geom=&quot;crossbar&quot;, width=0.2, color=&quot;orange&quot;) + geom_hline(yintercept=1.1, linetype=&quot;dashed&quot;, color = &quot;red&quot;) + ylim(0.9,2)+ labs(x=&quot;Model chains&quot;,y=&quot;Parameter estimates&quot;)+ theme_classic() In the beta plot, each dot represents the beta parameter of a different genome, while the dots in the gamma plot indicate different parameters related to phylogeny. We observe that both beta (response to dominance) and rho (phylogenetic signal) parameters display values around 1, with no outliers, indicating that the 4x250x1 model fitting was good enough for our purposes. "],["dominance-microbiome-analysis.html", "Chapter 10 Dominance-microbiome analysis 10.1 Predict responses to dominance 10.2 Plot traits linked to trends", " Chapter 10 Dominance-microbiome analysis load(&quot;data/data.Rdata&quot;) load(&quot;hmsc/fit_model1_250_10.Rdata&quot;) 10.0.1 Posterior estimates The next step is to get the posterior estimates of beta, which is the parameter that links dominance with the microbiome. We employ a support threshold of ‘0.05’ to assign significance, meaning that parameters with posterior overlaps of &lt;10% are considered significantly different. # Select desired support threshold support=0.9 negsupport=1-support # Basal tree postestimates_tree &lt;- genome_tree %&gt;% keep.tip(., tip=m$spNames) # Posterior estimate table post_beta &lt;- getPostEstimate(hM=m, parName=&quot;Beta&quot;)$support %&gt;% as.data.frame() %&gt;% mutate(variable=m$covNames) %&gt;% pivot_longer(!variable, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) %&gt;% mutate(genome=factor(genome, levels=rev(postestimates_tree$tip.label))) %&gt;% mutate(value = case_when( value &gt;= support ~ &quot;Positive&quot;, value &lt;= negsupport ~ &quot;Negative&quot;, TRUE ~ &quot;Neutral&quot;)) %&gt;% mutate(value=factor(value, levels=c(&quot;Positive&quot;,&quot;Neutral&quot;,&quot;Negative&quot;))) %&gt;% pivot_wider(names_from = variable, values_from = value) %&gt;% rename(intercept=2) %&gt;% select(genome,dominance,groupvariable) %&gt;% column_to_rownames(var=&quot;genome&quot;) # Aggregate basal GIFT into elements function_table &lt;- genome_gifts %&gt;% to.elements(., GIFT_db) %&gt;% as.data.frame() #Phylums phylum_colors &lt;- read_tsv(&quot;https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv&quot;) %&gt;% right_join(genome_metadata, by=join_by(phylum == phylum)) %&gt;% filter(genome %in% postestimates_tree$tip.label) %&gt;% arrange(match(genome, postestimates_tree$tip.label)) %&gt;% mutate(phylum = factor(phylum, levels = unique(phylum))) %&gt;% column_to_rownames(var = &quot;genome&quot;) %&gt;% select(phylum) colors_alphabetic &lt;- read_tsv(&quot;https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv&quot;) %&gt;% right_join(genome_metadata, by=join_by(phylum == phylum)) %&gt;% filter(genome %in% postestimates_tree$tip.label) %&gt;% arrange(match(genome, postestimates_tree$tip.label)) %&gt;% select(phylum, colors) %&gt;% unique() %&gt;% arrange(phylum) %&gt;% select(colors) %&gt;% pull() # Basal ggtree postestimates_tree &lt;- postestimates_tree %&gt;% force.ultrametric(.,method=&quot;extend&quot;) %&gt;% ggtree(., size = 0.3) *************************************************************** * Note: * * force.ultrametric does not include a formal method to * * ultrametricize a tree &amp; should only be used to coerce * * a phylogeny that fails is.ultrametric due to rounding -- * * not as a substitute for formal rate-smoothing methods. * *************************************************************** #Add phylum colors next to the tree tips postestimates_tree &lt;- gheatmap(postestimates_tree, phylum_colors, offset=-0.2, width=0.1, colnames=FALSE) + scale_fill_manual(values=colors_alphabetic)+ labs(fill=&quot;Phylum&quot;) #Reset fill scale to use a different colour profile in the heatmap postestimates_tree &lt;- postestimates_tree + new_scale_fill() # Add posterior significant heatmap postestimates_tree &lt;- gheatmap(postestimates_tree, post_beta, offset=0, width=0.2, colnames=TRUE, colnames_position=&quot;top&quot;,colnames_angle=90, colnames_offset_y=1, hjust=0) + scale_fill_manual(values=c(&quot;#be3e2b&quot;,&quot;#f4f4f4&quot;,&quot;#b2b530&quot;))+ labs(fill=&quot;Trend&quot;) #Reset fill scale to use a different colour profile in the heatmap postestimates_tree &lt;- postestimates_tree + new_scale_fill() #Add functions heatmap postestimates_tree &lt;- gheatmap(postestimates_tree, function_table, offset=0.6, width=3.5, colnames=FALSE) + vexpand(.08) + coord_cartesian(clip = &quot;off&quot;) + scale_fill_gradient(low = &quot;#f4f4f4&quot;, high = &quot;steelblue&quot;, na.value=&quot;white&quot;) + labs(fill=&quot;Function fullness&quot;) #Reset fill scale to use a different colour profile in the heatmap postestimates_tree &lt;- postestimates_tree + new_scale_fill() # Add completeness barplots postestimates_tree &lt;- postestimates_tree + geom_fruit(data=genome_metadata, geom=geom_bar, grid.params=list(axis=&quot;x&quot;, text.size=2, nbreak = 1), axis.params=list(vline=TRUE), mapping = aes(x=length, y=genome, fill=completeness), offset = 3.85, orientation=&quot;y&quot;, stat=&quot;identity&quot;) + scale_fill_gradient(low = &quot;#cf8888&quot;, high = &quot;#a2cc87&quot;) + labs(fill=&quot;Genome completeness&quot;) postestimates_tree + vexpand(.25, 1) # expand top ### Positively associated genomes getPostEstimate(hM=m, parName=&quot;Beta&quot;)$support %&gt;% as.data.frame() %&gt;% mutate(variable=m$covNames) %&gt;% pivot_longer(!variable, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) %&gt;% mutate(trend = case_when( value &gt;= support ~ &quot;Positive&quot;, value &lt;= negsupport ~ &quot;Negative&quot;, TRUE ~ &quot;Neutral&quot;)) %&gt;% filter(variable==&quot;dominance&quot;, trend==&quot;Positive&quot;) %&gt;% arrange(-value) %&gt;% left_join(genome_metadata,by=join_by(genome==genome)) %&gt;% select(genome,phylum,class,order,species,value) %&gt;% tt() tinytable_iamhfbcbacrjz7yuw8fk .table td.tinytable_css_1x4yvwad8vl6a81dxfpy, .table th.tinytable_css_1x4yvwad8vl6a81dxfpy { border-bottom: solid 0.1em #d3d8dc; } genome phylum class order species value A_DRC05_bin.59 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__Duncaniella sp910577345 1.000 C_HT_bin.102 p__Bacillota c__Bacilli o__Lactobacillales s__Limosilactobacillus reuteri 0.998 A_HTC12_bin.48 p__Bacillota c__Bacilli o__Lactobacillales s__Lactobacillus johnsonii 0.995 C_HT_bin.9 p__Bacillota_A c__Clostridia o__Oscillospirales s__QXXE01 sp910589115 0.994 A_DTC03_bin.77 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__CAG-873 sp910586975 0.992 B_C04M3_bin.80 p__Bacillota_A c__Clostridia o__Lachnospirales s__ 0.991 B_C05M2_bin.12 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__CAG-873 sp910578095 0.991 A_CDC10_bin.30 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__Duncaniella sp910589485 0.990 B_C03M5_bin.33 p__Bacillota_B c__Dehalobacteriia o__UBA4068 s__ 0.990 A_CDC13_bin.65 p__Bacillota_A c__Clostridia o__Lachnospirales s__Eubacterium_J sp009774535 0.987 A_T3C12_bin.34 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__CAG-485 sp009775355 0.985 C_DR_bin.56 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__CAG-485 sp910578075 0.985 B_C04M3_bin.108 p__Bacillota_A c__Clostridia o__Oscillospirales s__Acutalibacter sp009936035 0.984 B_C06M3_bin.61 p__Bacillota c__Bacilli o__Erysipelotrichales s__C-19 sp910576855 0.981 B_C12F1_bin.72 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__Duncaniella sp910578515 0.980 C_HR_bin.153 p__Bacillota_A c__Clostridia o__Oscillospirales s__ 0.980 A_T1C10_bin.3 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__UBA7173 sp002491305 0.979 B_C11F5_bin.68 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__UBA7173 sp001689485 0.979 B_C12F1_bin.61 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__CAG-873 sp009775535 0.977 A_DRC04_bin.49 p__Bacillota_A c__Clostridia o__Oscillospirales s__Enterenecus sp910587255 0.975 C_DR_bin.4 p__Bacillota_A c__Clostridia o__Oscillospirales s__Avispirillum sp011957885 0.974 A_HTC03_bin.32 p__Bacillota_A c__Clostridia o__Oscillospirales s__Pelethomonas sp910587645 0.973 B_C04M5_bin.101 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__Paramuribaculum sp910579675 0.973 B_C11F3_bin.29 p__Bacillota_A c__Clostridia o__Lachnospirales s__CAG-95 sp009911035 0.973 A_CDC12_bin.65 p__Bacillota_A c__Clostridia o__Christensenellales s__Coproplasma sp003979335 0.972 B_C13F3_bin.77 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__CAG-873 sp910587915 0.972 A_CDC13_bin.13 p__Bacillota_A c__Clostridia o__Lachnospirales s__UBA3402 sp002358555 0.971 B_C05M3_bin.38 p__Bacillota_A c__Clostridia o__Lachnospirales s__Eubacterium_J sp910574915 0.971 B_C13F3_bin.53 p__Bacillota c__Bacilli o__Erysipelotrichales s__Erysipelatoclostridium cocleatum 0.970 A_DTC13_bin.55 p__Bacillota_A c__Clostridia o__Christensenellales s__RACS-045 sp910579785 0.969 A_T2C12_bin.11 p__Bacillota_A c__Clostridia o__Oscillospirales s__NSJ-51 sp910585415 0.969 B_C06M5_bin.62 p__Bacillota_A c__Clostridia o__Christensenellales s__CAG-475 sp910577815 0.968 B_C13F3_bin.5 p__Bacillota_A c__Clostridia o__TANB77 s__ 0.967 B_C13F3_bin.97 p__Bacillota_A c__Clostridia o__TANB77 s__ 0.967 C_CR_bin.18 p__Bacillota_A c__Clostridia o__Lachnospirales s__VSOB01 sp910589075 0.966 C_DT_bin.159 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__ 0.965 A_T2C05_bin.3 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__Muribaculum gordoncarteri 0.964 B_C13F2_bin.43 p__Bacillota_A c__Clostridia o__Oscillospirales s__Enterenecus sp910587255 0.963 B_C04M3_bin.128 p__Bacillota_A c__Clostridia o__Oscillospirales s__Anaerotruncus sp000403395 0.962 B_C13F3_bin.35 p__Bacillota_A c__Clostridia o__Lachnospirales s__MGBC136627 sp910585935 0.961 A_OPC13_bin.50 p__Bacillota_A c__Clostridia o__Oscillospirales s__UBA1405 sp910589145 0.960 B_C05M1_bin.75 p__Bacillota_A c__Clostridia o__Lachnospirales s__Clostridium_Q sp009911305 0.959 B_C13F3_bin.70 p__Bacillota_A c__Clostridia o__Oscillospirales s__ 0.959 A_CDC05_bin.89 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__ 0.958 A_OPC10_bin.79 p__Bacillota_A c__Clostridia o__Lachnospirales s__UBA3402 sp910574345 0.957 C_OP_bin.44 p__Bacillota_A c__Clostridia o__Lachnospirales s__Ventrimonas sp910586205 0.957 C_HT_bin.137 p__Bacillota_A c__Clostridia o__Oscillospirales s__ 0.956 C_CR_bin.157 p__Bacillota_A c__Clostridia o__Christensenellales s__ 0.954 C_T3_bin.64 p__Bacillota_A c__Clostridia o__Oscillospirales s__NSJ-51 sp910585415 0.954 C_DR_bin.31 p__Bacillota_A c__Clostridia o__Lachnospirales s__Anaerotignum sp910576545 0.953 A_OPC10_bin.40 p__Bacillota_A c__Clostridia o__Oscillospirales s__ 0.952 B_C12F2_bin.47 p__Bacillota c__Bacilli o__Lactobacillales s__Enterococcus_D casseliflavus 0.952 C_HR_bin.13 p__Bacillota_A c__Clostridia o__Oscillospirales s__Evtepia sp910584805 0.952 C_T2_bin.55 p__Bacillota_A c__Clostridia o__Lachnospirales s__ 0.952 B_C04M2_bin.33 p__Bacillota_A c__Clostridia o__Oscillospirales s__Enterenecus sp910585265 0.951 B_C04M3_bin.31 p__Bacillota_A c__Clostridia o__Oscillospirales s__Angelakisella sp013316495 0.951 A_OPC03_bin.64 p__Bacillota_A c__Clostridia o__Lachnospirales s__Acetatifactor sp910589655 0.950 A_T1C11_bin.9 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__CAG-485 sp002362485 0.949 B_C04M3_bin.18 p__Bacillota_A c__Clostridia o__Lachnospirales s__Eubacterium_J sp910586445 0.949 B_C03M3_bin.127 p__Bacillota_A c__Clostridia o__Oscillospirales s__Acutalibacter sp009936035 0.948 B_C04M4_bin.45 p__Bacillota_A c__Clostridia o__Oscillospirales s__ 0.948 A_T3C03_bin.17 p__Bacillota_A c__Clostridia o__Christensenellales s__QANA01 sp910588425 0.947 B_C04M2_bin.76 p__Bacillota_A c__Clostridia o__Lachnospirales s__CAG-56 sp004793585 0.945 A_HRC11_bin.35 p__Bacillota_A c__Clostridia o__Oscillospirales s__ 0.944 B_C04M4_bin.5 p__Bacillota_A c__Clostridia o__Lachnospirales s__Choladocola sp009774145 0.944 C_DT_bin.37 p__Bacillota_A c__Clostridia o__Oscillospirales s__Acutalibacter sp009936035 0.944 C_DR_bin.21 p__Bacillota_A c__Clostridia o__Lachnospirales s__MD308 sp910578455 0.943 A_CDC03_bin.78 p__Bacillota_A c__Clostridia o__Oscillospirales s__Lawsonibacter sp910577805 0.942 B_C13F5_bin.28 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__Duncaniella sp910576785 0.942 A_HRC10_bin.28 p__Bacillota_A c__Clostridia o__Christensenellales s__Gallimonas sp910578065 0.941 A_T3C11_bin.23 p__Bacillota_A c__Clostridia o__Lachnospirales s__RGIG4284 sp910576205 0.941 A_HTC12_bin.21 p__Bacillota_A c__Clostridia o__Lachnospirales s__UBA3402 sp910575585 0.940 A_T2C05_bin.28 p__Bacillota c__Bacilli o__Erysipelotrichales s__MGBC163490 sp910588075 0.940 B_C10F2_bin.5 p__Bacillota_A c__Clostridia o__Oscillospirales s__ 0.940 C_HR_bin.146 p__Bacillota_A c__Clostridia o__Lachnospirales s__Choladocola sp910575445 0.940 B_C05M5_bin.57 p__Bacillota_A c__Clostridia o__Oscillospirales s__Pelethomonas sp910587785 0.939 B_C10F5_bin.45 p__Bacillota_A c__Clostridia o__Oscillospirales s__Dysosmobacter sp000403435 0.939 B_C12F3_bin.66 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__ 0.939 B_C11F5_bin.87 p__Bacillota_A c__Clostridia o__Lachnospirales s__ 0.938 A_CRC05_bin.32 p__Bacillota_A c__Clostridia o__Lachnospirales s__Eubacterium_J sp910579075 0.937 B_C04M1_bin.34 p__Bacillota_A c__Clostridia o__Oscillospirales s__Pelethomonas sp910579965 0.937 B_C04M3_bin.90 p__Bacillota_A c__Clostridia o__Lachnospirales s__14-2 sp910580015 0.937 C_T2_bin.30 p__Bacillota_A c__Clostridia o__Lachnospirales s__ 0.934 C_T3_bin.41 p__Bacillota_A c__Clostridia o__Lachnospirales s__Acetatifactor sp910584235 0.934 C_CD_bin.124 p__Bacillota_A c__Clostridia o__Oscillospirales s__Pelethomonas sp910579965 0.933 C_OP_bin.73 p__Bacillota_A c__Clostridia o__Lachnospirales s__UBA3402 sp910585435 0.933 C_HR_bin.50 p__Bacillota_A c__Clostridia o__Lachnospirales s__UBA3402 sp910588325 0.932 A_CDC03_bin.64 p__Bacillota_A c__Clostridia o__Lachnospirales s__ 0.930 B_C03M3_bin.121 p__Bacillota_A c__Clostridia o__Lachnospirales s__Lachnoclostridium_B sp910574185 0.930 B_C10F1_bin.59 p__Bacillota_A c__Clostridia o__Lachnospirales s__Choladocola sp910583895 0.929 B_C10F5_bin.36 p__Bacillota_A c__Clostridia o__Lachnospirales s__UBA3282 sp003611805 0.928 B_C11F5_bin.21 p__Bacillota_A c__Clostridia o__Lachnospirales s__COE1 sp000403335 0.928 A_CDC10_bin.13 p__Bacillota_A c__Clostridia o__Christensenellales s__MGBC113161 sp910587565 0.927 A_DRC13_bin.41 p__Bacillota_A c__Clostridia o__Oscillospirales s__Acutalibacter muris 0.927 C_CD_bin.62 p__Bacillota_A c__Clostridia o__Lachnospirales s__1XD42-69 sp009911505 0.925 C_OP_bin.15 p__Bacillota_A c__Clostridia o__Lachnospirales s__Roseburia sp910584215 0.925 A_CDC05_bin.91 p__Bacillota_A c__Clostridia o__Oscillospirales s__ 0.923 C_T2_bin.92 p__Bacillota_A c__Clostridia o__TANB77 s__ 0.923 A_CDC05_bin.30 p__Bacillota_A c__Clostridia o__Oscillospirales s__ 0.922 A_CRC04_bin.71 p__Bacillota_A c__Clostridia o__Lachnospirales s__Sporofaciens sp910574885 0.922 B_C13F3_bin.99 p__Bacillota_A c__Clostridia o__Lachnospirales s__Merdisoma sp910574255 0.922 B_C04M1_bin.8 p__Bacillota_A c__Clostridia o__Lachnospirales s__Merdisoma sp910576325 0.921 B_C03M2_bin.44 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__Duncaniella muris 0.920 B_C06M5_bin.16 p__Actinomycetota c__Coriobacteriia o__Coriobacteriales s__Adlercreutzia muris 0.920 C_T3_bin.99 p__Bacillota_A c__Clostridia o__Oscillospirales s__Pelethomonas sp910577915 0.920 B_C05M1_bin.6 p__Bacillota_A c__Clostridia o__Lachnospirales s__Ventrimonas sp910584845 0.919 A_DRC06_bin.37 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__CAG-873 sp009775265 0.918 B_C12F1_bin.38 p__Bacillota_A c__Clostridia o__Oscillospirales s__Dysosmobacter sp910588005 0.918 B_C10F1_bin.10 p__Bacillota_A c__Clostridia o__Lachnospirales s__Ventrimonas sp910577765 0.917 B_C13F3_bin.93 p__Bacillota_A c__Clostridia o__Oscillospirales s__Anaerotruncus sp003612625 0.917 A_HRC05_bin.71 p__Bacillota_A c__Clostridia o__Christensenellales s__MGBC100320 sp910577995 0.915 A_T3C13_bin.3 p__Bacillota_A c__Clostridia o__Oscillospirales s__ 0.914 B_C03M1_bin.60 p__Bacillota_A c__Clostridia o__Christensenellales s__MGBC100798 sp910584975 0.911 C_OP_bin.100 p__Bacillota_A c__Clostridia o__Lachnospirales s__ 0.910 C_DT_bin.155 p__Bacillota_A c__Clostridia o__Lachnospirales s__ 0.909 A_T1C03_bin.24 p__Bacillota_A c__Clostridia o__Lachnospirales s__UMGS1370 sp910577645 0.907 B_C12F1_bin.23 p__Bacillota_A c__Clostridia o__Oscillospirales s__Pelethomonas sp910579965 0.907 A_T2C13_bin.14 p__Bacteroidota c__Bacteroidia o__Bacteroidales s__UBA7173 sp001689685 0.906 A_CRC05_bin.73 p__Bacillota_A c__Clostridia o__Christensenellales s__MGBC100320 sp910588305 0.905 B_C03M1_bin.29 p__Bacillota_A c__Clostridia o__Lachnospirales s__Ventrimonas sp009911065 0.905 B_C04M5_bin.14 p__Actinomycetota c__Coriobacteriia o__Coriobacteriales s__Adlercreutzia caecimuris 0.905 C_HR_bin.28 p__Bacillota_A c__Clostridia o__Lachnospirales s__Sporofaciens sp910585725 0.903 B_C04M5_bin.93 p__Bacillota_A c__Clostridia o__Christensenellales s__Gallimonas sp910588465 0.902 10.0.2 Negatively associated genomes getPostEstimate(hM=m, parName=&quot;Beta&quot;)$support %&gt;% as.data.frame() %&gt;% mutate(variable=m$covNames) %&gt;% pivot_longer(!variable, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) %&gt;% mutate(trend = case_when( value &gt;= support ~ &quot;Positive&quot;, value &lt;= negsupport ~ &quot;Negative&quot;, TRUE ~ &quot;Neutral&quot;)) %&gt;% filter(variable==&quot;dominance&quot;, trend==&quot;Negative&quot;) %&gt;% arrange(value) %&gt;% left_join(genome_metadata,by=join_by(genome==genome)) %&gt;% select(genome,phylum,class,order,species,value) %&gt;% tt() tinytable_5x1r38xihzc30pe4jwl8 .table td.tinytable_css_ycuuaqtc5vtk67tquipl, .table th.tinytable_css_ycuuaqtc5vtk67tquipl { border-bottom: solid 0.1em #d3d8dc; } genome phylum class order species value A_T3C05_bin.41 p__Pseudomonadota c__Gammaproteobacteria o__Burkholderiales s__Parasutterella excrementihominis 0.095 10.1 Predict responses to dominance Based on the fitted model, we can predict the structure of the microbial community for each level of dominance for a certain value of sequencing depth. # Select modelchain of interest load(&quot;hmsc/fit_model1_250_10.Rdata&quot;) gradient = seq(0,1,0.1) gradientlength = length(gradient) #Treatment-specific gradient predictions pred &lt;- constructGradient(m, focalVariable = &quot;dominance&quot;, non.focalVariables = list(logseqdepth=list(1)), ngrid=gradientlength) %&gt;% predict(m, Gradient = ., expected = TRUE) # weights: 3 (2 variable) initial value 162.196440 final value 133.205769 converged predY &lt;- pred %&gt;% do.call(rbind,.) %&gt;% as.data.frame() %&gt;% mutate(dominance=rep(gradient,1000)) %&gt;% pivot_longer(-c(dominance), names_to = &quot;genome&quot;, values_to = &quot;value&quot;) 10.1.1 Plot responses to dominance The estimated responses of genomes exhibiting significant positive and negative association with dominance. #Get phylum colors from the EHI standard phylum_colors &lt;- genome_metadata %&gt;% left_join(read_tsv(&quot;https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv&quot;), by=join_by(phylum == phylum)) %&gt;% arrange(match(genome, genome_tree$tip.label)) %&gt;% select(phylum, colors) %&gt;% unique() %&gt;% arrange(phylum) %&gt;% slice(2:5) %&gt;% select(colors) %&gt;% pull() getPostEstimate(hM=m, parName=&quot;Beta&quot;)$support %&gt;% as.data.frame() %&gt;% mutate(variable=m$covNames) %&gt;% pivot_longer(!variable, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) %&gt;% mutate(trend = case_when( value &gt;= support ~ &quot;Positive&quot;, value &lt;= negsupport ~ &quot;Negative&quot;, TRUE ~ &quot;Neutral&quot;)) %&gt;% filter(variable==&quot;dominance&quot;, trend!=&quot;Neutral&quot;) %&gt;% select(genome,trend) %&gt;% left_join(predY, by=join_by(genome==genome)) %&gt;% filter(trend != &quot;Neutral&quot;) %&gt;% #filter(genome %in% predY_asc) %&gt;% #only display genomes with contrasting dynamics across treatments group_by(genome, trend, dominance) %&gt;% summarize(value = mean(value, na.rm = TRUE)) %&gt;% left_join(genome_metadata, by=join_by(genome == genome)) %&gt;% ggplot(aes(x=dominance, y=value, group=genome, color=phylum)) + geom_line() + scale_color_manual(values=phylum_colors) + facet_grid(fct_rev(trend) ~ phylum) + labs(y=&quot;Genome abundance (log)&quot;,x=&quot;Dominance&quot;) + theme(legend.position = &quot;none&quot;) + theme_minimal() + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 45, hjust = 0.8,), axis.line.x = element_line(size = 0.5, linetype = &quot;solid&quot;, colour = &quot;black&quot;), ) 10.2 Plot traits linked to trends 10.2.1 Test functional trait differences Using Wilcoxon test with Benjamini-Hochberg procedure for FDR, identify functional traits that differ between genomes that are either positively or negatively association with dominance. postestimate_test &lt;- getPostEstimate(hM=m, parName=&quot;Beta&quot;)$support %&gt;% as.data.frame() %&gt;% mutate(variable=m$covNames) %&gt;% pivot_longer(!variable, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) %&gt;% mutate(trend = case_when( value &gt;= support ~ &quot;Positive&quot;, value &lt;= negsupport ~ &quot;Negative&quot;, TRUE ~ &quot;Neutral&quot;)) %&gt;% filter(variable==&quot;dominance&quot;, trend!=&quot;Neutral&quot;) %&gt;% select(genome,trend) %&gt;% left_join(function_table %&gt;% rownames_to_column(var=&quot;genome&quot;), by=join_by(genome==genome)) %&gt;% pivot_longer(-c(genome,trend), names_to = &quot;trait&quot;, values_to = &quot;value&quot;) %&gt;% group_by(trait) %&gt;% summarise(p_value = wilcox.test(value ~ trend)$p.value) %&gt;% mutate(p_adjust=p.adjust(p_value, method=&quot;BH&quot;)) %&gt;% filter(p_adjust &lt; 0.05) There are no traits that differ significantly between positively and negatively associated genomes. 10.2.2 Plot functional trait differences (not useful, as there are no differences) postestimate_support %&gt;% rownames_to_column(var=&quot;genome&quot;) %&gt;% filter(trend != &quot;Neutral&quot;) %&gt;% left_join(function_table %&gt;% rownames_to_column(var=&quot;genome&quot;), by=join_by(genome==genome)) %&gt;% pivot_longer(-c(genome,trend), names_to = &quot;trait&quot;, values_to = &quot;value&quot;) %&gt;% filter(trait %in% postestimate_test$trait) %&gt;% #filter significantly different functions filter(trait != &quot;S0201&quot;) %&gt;% #remove structural trait ggplot(.,aes(x=value, y=trend, fill=trend, color=trend)) + #geom_boxplot(color=&quot;black&quot;) + geom_violin() + scale_color_manual(values=c(&quot;#cf8888&quot;,&quot;#a2cc87&quot;))+ scale_fill_manual(values=c(&quot;#cf8888&quot;,&quot;#a2cc87&quot;))+ facet_grid(trait ~ ., space=&quot;free&quot;)+ theme_classic() + labs(x=&quot;Metabolic Capacity Index&quot;,y=&quot;Metabolic function&quot;, fill=&quot;Trend&quot;, color=&quot;Trend&quot;) + theme(strip.text.y = element_text(angle = 0), strip.background = element_blank(), axis.text.y=element_blank()) 10.2.3 Community functional predictions function_table2 &lt;- function_table %&gt;% to.functions(., GIFT_db) community_gifts &lt;- predY %&gt;% group_by(dominance, genome) %&gt;% mutate(row_id = row_number()) %&gt;% pivot_wider(names_from = genome, values_from = value) %&gt;% ungroup() %&gt;% group_split(row_id) %&gt;% as.list() %&gt;% lapply(., FUN = function(x){x %&gt;% select(-row_id) %&gt;% column_to_rownames(var = &quot;dominance&quot;) %&gt;% as.data.frame() %&gt;% exp() %&gt;% t() %&gt;% tss() %&gt;% to.community(function_table2,.,GIFT_db) %&gt;% as.data.frame() %&gt;% rownames_to_column(var=&quot;dominance&quot;) }) community_gifts %&gt;% bind_rows() %&gt;% pivot_longer(-dominance, names_to = &quot;trait&quot;, values_to = &quot;value&quot;) %&gt;% mutate(dominance=as.numeric(dominance)) %&gt;% filter(trait==&quot;B0218&quot;) %&gt;% ggplot(.,aes(x=dominance, y=value)) + geom_point() + geom_smooth(method = lm, formula = y ~ splines::bs(x, 3), se = TRUE) + theme_classic() + labs(x=&quot;Dominance&quot;,y=&quot;Metabolic Capacity Index&quot;) community_gifts %&gt;% bind_rows() %&gt;% pivot_longer(-dominance, names_to = &quot;trait&quot;, values_to = &quot;value&quot;) %&gt;% mutate(dominance=as.numeric(dominance)) %&gt;% #filter(trait==&quot;B03&quot;) %&gt;% ggplot(.,aes(x=dominance, y=value)) + geom_point() + geom_quantile(quantiles = 0.05, formula = y ~ splines::bs(x, 3)) + geom_quantile(quantiles = 0.5, formula = y ~ splines::bs(x, 3)) + geom_quantile(quantiles = 0.95, formula = y ~ splines::bs(x, 3)) + facet_grid(. ~ trait, ) + theme_classic() + labs(x=&quot;Dominance&quot;,y=&quot;Metabolic Capacity Index&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
